# hash-zig

[![CI](https://github.com/ch4r10t33r/hash-zig/actions/workflows/ci.yml/badge.svg)](https://github.com/ch4r10t33r/hash-zig/actions/workflows/ci.yml)
[![Zig](https://img.shields.io/badge/zig-0.14.1-orange.svg)](https://ziglang.org/)
[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](LICENSE)

A pure Zig implementation of **Generalized XMSS** hash-based signatures with **100% Rust compatibility**. This library implements the complete GeneralizedXMSS signature scheme based on the framework from [this paper](https://eprint.iacr.org/2025/055.pdf), matching the [hash-sig](https://github.com/b-wagn/hash-sig) Rust implementation exactly.

## ğŸŒŸ Features

### âœ… **100% Rust Compatibility**
- **Complete GeneralizedXMSS Implementation**: Full signature scheme matching Rust implementation
- **Identical API**: Same function signatures and behavior as Rust version
- **Cross-Implementation Interop**: Signatures can be verified exactly between Rust and Zig
- **Random Parameter Generation**: Uses truly random PRF keys and parameters (matching Rust)
- **Top-Bottom Tree Architecture**: Implements the complete Merkle tree construction
- **Secret Key Management**: Full support for activation intervals and key advancement

### ğŸ” **Cryptographic Components**
- **Poseidon2 Hash Function**: KoalaBear field with Montgomery arithmetic
- **ShakePRFtoF**: SHAKE128-based PRF for key derivation
- **TargetSum Encoding**: Incomparable binary encoding with randomness
- **Merkle Tree Construction**: Complete tree building with parallel processing support

### ğŸš€ **Performance & Quality**
- **128-bit Post-Quantum Security**: Well-tested security level
- **Multiple Lifetimes**: Support for 2^8, 2^18, and 2^32 signatures per keypair
- **Memory Safe**: Proper memory management with no leaks
- **Pure Zig**: Minimal dependencies, fully type-safe
- **Comprehensive Testing**: Full test suite with compatibility verification

## ğŸ“‹ Table of Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [Architecture](#architecture)
- [API Reference](#api-reference)
- [Testing](#testing)
- [Performance](#performance)
- [Contributing](#contributing)
- [License](#license)

## ğŸš€ Installation

### Using Zig Package Manager

Add to your `build.zig.zon`:

```zig
.{
    .name = "my_project",
    .version = "0.1.0",
    .dependencies = .{
        .@"hash-zig" = .{
            .url = "https://github.com/ch4r10t33r/hash-zig/archive/refs/tags/v0.1.0.tar.gz",
            .hash = "1220...", // Will be generated by zig build
        },
        .@"zig-poseidon" = .{
            .url = "https://github.com/blockblaz/zig-poseidon/archive/refs/tags/v0.2.0.tar.gz",
            .hash = "1220...", // Will be generated by zig build
        },
    },
}
```

In your `build.zig`:

```zig
const hash_zig_dep = b.dependency("hash-zig", .{
    .target = target,
    .optimize = optimize,
});
const zig_poseidon_dep = b.dependency("zig_poseidon", .{
    .target = target,
    .optimize = optimize,
});

exe.root_module.addImport("hash-zig", hash_zig_dep.module("hash-zig"));
exe.root_module.addImport("poseidon", zig_poseidon_dep.module("poseidon"));
```

### Manual Installation

```bash
git clone https://github.com/ch4r10t33r/hash-zig.git
cd hash-zig
zig build test
```

## âš¡ Quick Start

```zig
const std = @import("std");
const hash_zig = @import("hash-zig");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Initialize the GeneralizedXMSS signature scheme
    var scheme = try hash_zig.GeneralizedXMSSSignatureScheme.init(allocator, .lifetime_2_8);
    defer scheme.deinit();

    // Generate a keypair with activation parameters
    const keypair = try scheme.keyGen(0, 256); // activation_epoch=0, num_active_epochs=256
    defer keypair.secret_key.deinit();

    // Sign a message
    const message = [_]u8{0x42} ** 32;
    const signature = try scheme.sign(keypair.secret_key, 0, message);
    defer signature.deinit();

    // Verify the signature
    const is_valid = try scheme.verify(&keypair.public_key, 0, message, signature);
    std.debug.print("Signature valid: {}\n", .{is_valid});
}
```

## ğŸ—ï¸ Architecture

### Core Components

#### **GeneralizedXMSSSignatureScheme**
The main signature scheme implementation that provides:
- `keyGen(activation_epoch, num_active_epochs)` - Generate keypairs
- `sign(secret_key, epoch, message)` - Sign messages
- `verify(public_key, epoch, message, signature)` - Verify signatures

#### **Data Structures**
- **GeneralizedXMSSPublicKey**: Contains root and parameters
- **GeneralizedXMSSSecretKey**: Contains PRF key, parameters, and tree state
- **GeneralizedXMSSSignature**: Contains Merkle path, randomness, and hashes

#### **Cryptographic Primitives**
- **ShakePRFtoF**: SHAKE128-based PRF for key derivation
- **Poseidon2**: KoalaBear field hash function for tree construction
- **TargetSum Encoding**: Binary encoding with randomness

### Lifetime Support

| Lifetime | Signatures | Use Case |
|----------|------------|----------|
| `2^8` | 256 | Testing, short-term keys |
| `2^18` | 262,144 | Medium-term applications |
| `2^32` | 4,294,967,296 | Long-term, high-volume |

## ğŸ“– API Reference

### Key Generation

```zig
// Generate a keypair for lifetime 2^8
const keypair = try scheme.keyGen(0, 256);

// Access the public key
const public_key = keypair.public_key;
std.debug.print("Root: {}\n", .{public_key.root.value});

// Access the secret key
const secret_key = keypair.secret_key;
const activation_interval = secret_key.getActivationInterval();
const prepared_interval = secret_key.getPreparedInterval(8);
```

### Signing and Verification

```zig
// Sign a message at epoch 0
const message = [_]u8{0x42} ** 32;
const signature = try scheme.sign(secret_key, 0, message);

// Verify the signature
const is_valid = try scheme.verify(&public_key, 0, message, signature);
```

### Secret Key Management

```zig
// Check if key is active for a given epoch
const activation_interval = secret_key.getActivationInterval();
if (activation_interval.contains(epoch)) {
    // Key is active for this epoch
}

// Check if key is prepared for a given epoch
const prepared_interval = secret_key.getPreparedInterval(log_lifetime);
if (prepared_interval.contains(epoch)) {
    // Key is prepared for this epoch
}

// Advance key preparation (when needed)
try secret_key.advancePreparation(log_lifetime);
```

## ğŸ§ª Testing

### Run All Tests

```bash
# Run comprehensive test suite
zig build test

# Run only Rust compatibility tests
zig build test-rust-compat

# Run specific compatibility tests
zig build test-generalized-xmss-compat
zig build test-shake-prf-compat
zig build test-poseidon2-compat
```

### Test Coverage

- âœ… **Unit Tests**: Individual component testing
- âœ… **Integration Tests**: Full signature scheme testing
- âœ… **Compatibility Tests**: Rust implementation matching
- âœ… **Performance Tests**: Benchmarking and timing
- âœ… **Memory Tests**: Leak detection and management

## ğŸš€ Performance

### Benchmarking

```bash
# Run performance benchmarks
zig build benchmark
```

### Performance Characteristics

- **Key Generation**: ~100ms for lifetime 2^8 (on M2 MacBook)
- **Signing**: ~1ms per signature
- **Verification**: ~2ms per signature
- **Memory Usage**: Efficient with proper cleanup

## ğŸ”§ Development

### Building

```bash
# Build library and examples
zig build

# Build with documentation
zig build -Ddocs

# Run linting
zig build lint
```

### Project Structure

```
src/
â”œâ”€â”€ core/           # Core types and parameters
â”œâ”€â”€ hash/           # Hash function implementations
â”œâ”€â”€ prf/            # PRF implementations
â”œâ”€â”€ signature/      # Main signature scheme
â”œâ”€â”€ merkle/         # Merkle tree construction
â”œâ”€â”€ wots/           # Winternitz OTS
â””â”€â”€ utils/          # Utility functions

examples/
â”œâ”€â”€ test_generalized_xmss_compat.zig    # Main compatibility test
â”œâ”€â”€ test_shake_prf_compatibility.zig    # PRF compatibility test
â””â”€â”€ test_poseidon2_compatibility.zig    # Hash function compatibility test

test/
â”œâ”€â”€ performance_test.zig               # Performance benchmarks
â””â”€â”€ rust_compatibility_test.zig        # Rust compatibility tests
```

## ğŸ¤ Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Ensure all tests pass: `zig build test`
6. Submit a pull request

### Development Guidelines

- Follow Zig naming conventions
- Add comprehensive tests for new features
- Ensure Rust compatibility is maintained
- Document public APIs
- Use proper memory management

## ğŸ“„ License

This project is licensed under the Apache License 2.0 - see the [LICENSE](LICENSE) file for details.

## ğŸ™ Acknowledgments

- [hash-sig](https://github.com/b-wagn/hash-sig) - Rust reference implementation
- [zig-poseidon](https://github.com/blockblaz/zig-poseidon) - Poseidon2 implementation
- [Generalized XMSS Paper](https://eprint.iacr.org/2025/055.pdf) - Cryptographic framework

## ğŸ“ Support

For questions, issues, or contributions:
- Open an issue on GitHub
- Check the [analysis](analysis/) directory for detailed implementation notes
- Review the [RUST_COMPATIBILITY.md](RUST_COMPATIBILITY.md) for compatibility details