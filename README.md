# hash-zig

[![CI](https://github.com/blockblaz/hash-zig/actions/workflows/ci.yml/badge.svg)](https://github.com/blockblaz/hash-zig/actions/workflows/ci.yml)
[![Zig](https://img.shields.io/badge/zig-0.14.1-orange.svg)](https://ziglang.org/)
[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](LICENSE)

Pure Zig implementation of **Generalized XMSS** signatures with wire-compatible behavior against the Rust reference implementation ([leanSig](https://github.com/leanEthereum/leanSig)). Keys, signatures, and Merkle paths interchange freely between the two ecosystems for lifetimes `2^8`, `2^18`, and `2^32`.

**✅ Cross-Language Compatibility**: All cross-language compatibility tests pass for lifetimes `2^8`, `2^18`, and `2^32`. Signatures generated by Rust can be verified by Zig and vice versa.

**⚠️ Prototype Status**: This is a prototype implementation for research and development purposes. Use at your own risk.

- **Protocol fidelity** – Poseidon2 hashing, ShakePRF domain separation, target sum encoding, and Merkle construction match the Rust reference bit-for-bit.
- **Multiple lifetimes** – `2^8`, `2^18`, `2^32` signatures per key with configurable activation windows (defaults to 256 epochs).
- **Interop-first CI & tooling** – `github/workflows/ci.yml` runs `benchmark/benchmark.py`, covering same-language and cross-language checks for lifetimes `2^8` and `2^18`. Locally, test all lifetimes (`2^8`, `2^18`, `2^32`) via `--lifetime` and enable verbose logs only when needed with `BENCHMARK_DEBUG_LOGS=1`.
- **Pure Zig** – minimal dependencies, explicit memory management, ReleaseFast-ready.

## Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [Cross-Language Compatibility Tests](#cross-language-compatibility-tests)
- [Performance Benchmarks](#performance-benchmarks)
- [Debug Logging](#debug-logging)
- [Development](#development)
- [License](#license)

## Installation

### Using the Zig package manager

`build.zig.zon`:

```zig
.{
    .name = "my_project",
    .version = "0.1.0",
    .dependencies = .{
        .@"hash-zig" = .{
            .url = "https://github.com/ch4r10t33r/hash-zig/archive/refs/tags/v2.0.0.tar.gz",
            .hash = "1220...", // generated by zig build
        },
        .@"zig-poseidon" = .{
            .url = "https://github.com/blockblaz/zig-poseidon/archive/refs/heads/main.tar.gz",
            .hash = "1220...", // generated by zig build
        },
    },
}
```

`build.zig`:

```zig
const hash_zig_dep = b.dependency("hash-zig", .{ .target = target, .optimize = optimize });
const zig_poseidon_dep = b.dependency("zig_poseidon", .{ .target = target, .optimize = optimize });

exe.root_module.addImport("hash-zig", hash_zig_dep.module("hash-zig"));
exe.root_module.addImport("poseidon", zig_poseidon_dep.module("poseidon"));
```

### Manual

```bash
git clone https://github.com/ch4r10t33r/hash-zig.git
cd hash-zig
zig build test
```

## Quick Start

### Basic Usage

```zig
const std = @import("std");
const hash_zig = @import("hash-zig");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Initialize scheme with desired lifetime
    var scheme = try hash_zig.GeneralizedXMSSSignatureScheme.init(allocator, .lifetime_2_8);
    defer scheme.deinit();

    // Generate keypair (start_epoch=0, num_active_epochs=256)
    const keypair = try scheme.keyGen(0, 256);
    defer keypair.secret_key.deinit();

    // Sign a message at epoch 0
    const message = [_]u8{0x42} ** 32;
    const signature = try scheme.sign(keypair.secret_key, 0, message);
    defer signature.deinit();

    // Verify the signature
    const ok = try scheme.verify(&keypair.public_key, 0, message, signature);
    std.debug.print("Signature valid: {}\n", .{ok});
}
```

### Using a Deterministic Seed

For reproducible key generation (useful for testing and cross-language compatibility):

```zig
// Generate a 32-byte seed
const seed = [_]u8{0x42} ** 32;

// Initialize scheme with seed
var scheme = try hash_zig.GeneralizedXMSSSignatureScheme.initWithSeed(
    allocator, 
    .lifetime_2_8, 
    seed
);
defer scheme.deinit();

// Generate keypair (deterministic based on seed)
const keypair = try scheme.keyGen(0, 256);
```

### Available Lifetimes

- `.lifetime_2_8` - 256 signatures (fast, suitable for testing)
- `.lifetime_2_18` - 262,144 signatures (production use)
- `.lifetime_2_32` - 4,294,967,296 signatures (experimental, very slow keygen)

> **Performance Note**: For lifetimes `2^18` and `2^32`, always compile with `zig build -Doptimize=ReleaseFast` for acceptable performance. Debug builds will be extremely slow for larger lifetimes.

## Cross-Language Compatibility Tests

The repository ships a helper script `benchmark/benchmark.py` that exercises both implementations (Zig ↔ Rust) in ReleaseFast mode. **All cross-language compatibility tests are currently passing** ✅ for lifetimes `2^8`, `2^18`, and `2^32`.

The test suite performs:
- Deterministic key generation for lifetimes `2^8`, `2^18`, and `2^32` with 256 active epochs
- Signing with each implementation
- Verification by both implementations (self + cross)
- Timing and artifact summaries written to `/tmp`

Verbose hash-level traces are suppressed unless you opt in with `BENCHMARK_DEBUG_LOGS=1`.

### Prerequisites

```bash
python3 --version  # Python 3.8+
zig version        # 0.14.1
cargo --version    # Rust 1.87.0+ toolchain
```

### Recommended Usage

```bash
# Run all supported lifetimes (2^8, 2^18, 2^32)
python3 benchmark/benchmark.py --lifetime "2^8,2^18,2^32"

# Run specific lifetime
python3 benchmark/benchmark.py --lifetime 2^8
python3 benchmark/benchmark.py --lifetime 2^18
python3 benchmark/benchmark.py --lifetime 2^32

# Enable verbose cross-implementation debug logs
BENCHMARK_DEBUG_LOGS=1 python3 benchmark/benchmark.py --lifetime 2^8

# Use custom seed for deterministic testing
python3 benchmark/benchmark.py --lifetime 2^8 --seed-hex <64-hex-char-seed>
```

The script automatically:

1. Builds the Zig helper (`cross-lang-zig-tool`) with `zig build install -Doptimize=ReleaseFast`
2. Builds the Rust helper (`cross_lang_rust_tool`) in `--release` mode
3. Runs comprehensive cross-language tests:
   - Rust sign → Rust verify (self-test)
   - Rust sign → Zig verify (cross-language)
   - Zig sign → Zig verify (self-test)
   - Zig sign → Rust verify (cross-language)
4. Reports PASS/FAIL and timing information for each test, plus artifact paths in `/tmp/rust_public_*` and `/tmp/zig_public_*`

### Test Results

All cross-language compatibility tests pass for all supported lifetimes:

**Lifetime 2^8 (256 active epochs):**
- ✅ Rust sign (keygen): ~0.05s
- ✅ Rust sign → Rust verify: ~0.005s
- ✅ Rust sign → Zig verify: ~0.011s
- ✅ Zig sign (keygen): ~1.2s
- ✅ Zig sign → Zig verify: ~0.011s
- ✅ Zig sign → Rust verify: ~0.005s

**Lifetime 2^32 (256 active epochs):**
- ✅ Rust sign (keygen): ~2.1s
- ✅ Rust sign → Rust verify: ~0.005s
- ✅ Rust sign → Zig verify: ~0.011s
- ✅ Zig sign (keygen): ~916s (~15.3 minutes)
- ✅ Zig sign → Zig verify: ~0.033s
- ✅ Zig sign → Rust verify: ~0.013s

> **Note**: Zig key generation for lifetime 2^32 takes significantly longer than Rust. This is expected due to the larger Merkle tree structure. For production use, consider pre-generating keys or using Rust for key generation.

### CI Reference

The compatibility logic lives in `.github/workflows/ci.yml` and can be used as a reference. The CI runs tests for lifetimes `2^8` and `2^18` by default.

### Cleanup

Delete test artifacts between runs if you want a clean slate:
```bash
rm /tmp/*_public_* /tmp/*_signature_*
```

### Rust Debug Tools Feature

The Rust benchmark tools include a `remote_hashsig_tool` binary that uses debug-only APIs from `leansig`. This tool is conditionally compiled and requires the `debug-tools` feature:

```bash
# Build with debug tools enabled
cargo build --release --features debug-tools --bin remote_hashsig_tool

# Without debug tools (default for cross-language tests)
cargo build --release --bin cross_lang_rust_tool
```

The main cross-language compatibility tests (`cross_lang_rust_tool`) work without the `debug-tools` feature and can be used with either local or remote `leansig` dependencies.

## Debug Logging

The hash-zig library includes extensive debug logging that can impact performance. All debug logging is controlled by a build-time feature flag `enable_debug_logs` that defaults to `false`.

### Default Behavior (Debug Logs Disabled)

By default, debug logs are **disabled** for optimal performance:

```bash
# Debug logs disabled (default)
zig build test-lifetimes
zig build test-lifetimes -OReleaseFast
```

### Enable Debug Logs

To enable debug logs for debugging purposes:

```bash
# Enable debug logs
zig build test-lifetimes -Ddebug-logs=true
zig build test-lifetimes -OReleaseFast -Ddebug-logs=true
```

### Performance Impact

When debug logs are disabled (default):
- **Zero overhead**: The `log.print()` function returns immediately
- **Compiler optimization**: In ReleaseFast builds, the check is optimized away
- **Clean output**: No debug noise in benchmark results

When debug logs are enabled:
- **Full logging**: All debug statements are printed
- **Performance impact**: String formatting and I/O operations add overhead
- **Useful for debugging**: Helps trace execution flow and identify issues

### Benchmarking Best Practices

**For Performance Benchmarks:**

Always run benchmarks **without** debug logs:

```bash
# Recommended for benchmarking
zig build test-lifetimes -OReleaseFast

# Or explicitly disable (though it's default)
zig build test-lifetimes -OReleaseFast -Ddebug-logs=false
```

**For Debugging:**

Enable debug logs when investigating issues:

```bash
# Enable debug logs for debugging
zig build test-lifetimes -Ddebug-logs=true

# Or with ReleaseFast for performance debugging
zig build test-lifetimes -OReleaseFast -Ddebug-logs=true
```

### Debug Log Categories

The following debug log prefixes are used:

- `ZIG_SIGN_DEBUG`: Signing operation debug logs
- `ZIG_VERIFY_DEBUG`: Verification operation debug logs
- `ZIG_HASH_CALL`: Hash function call logs
- `ZIG_HASH_RESULT`: Hash function result logs
- `ZIG_BUILDTREE`: Tree building debug logs
- `ZIG_BOTTOM_ROOT`: Bottom tree root computation logs
- `DEBUG:`: General debug messages

### Example

```bash
# Run benchmark without debug logs (fast, clean output)
$ zig build test-lifetimes -OReleaseFast
Testing Lifetime: 2^8
⏱️  Key Generation Time: 1.671 seconds
   ✅ Epoch 0: Sign=279.105ms, Verify=1.099ms
   ✅ Epoch 1: Sign=4.586ms, Verify=1.086ms
...

# Run with debug logs (verbose, slower)
$ zig build test-lifetimes -OReleaseFast -Ddebug-logs=true
Testing Lifetime: 2^8
ZIG_SIGN_DEBUG: Reusing 4 bottom tree layers from stored tree...
ZIG_HASH_CALL: level=0 pos=8 tweak=0x...
DEBUG: Tree tweak level=1 pos=8 -> 0x...
⏱️  Key Generation Time: 1.671 seconds
...
```

### Summary

- ✅ **Default**: Debug logs are **disabled** for optimal performance
- ✅ **Benchmarking**: Use default (no debug logs) for accurate performance measurements
- ✅ **Debugging**: Use `-Ddebug-logs=true` when investigating issues
- ✅ **Zero overhead**: When disabled, logging has no performance impact

## Performance Benchmarks

Performance measurements are taken using `zig build test-lifetimes` with ReleaseFast optimization. All benchmarks are run with debug logging disabled for accurate performance measurements.

### Lifetime 2^8 (256 Active Epochs)

**Key Generation:**
- Time: **~1.2 seconds**

**Signing Performance:**
- Average: **~5-10 ms** per signature
- First signature (epoch 0): **~280 ms** (includes tree building)
- Subsequent signatures: **~4-6 ms**

**Verification Performance:**
- Average: **~1-2 ms** per verification

### Lifetime 2^18 (256 Active Epochs)

**Key Generation:**
- Time: **~10-20 seconds**

**Signing Performance:**
- Average: **~10-20 ms** per signature
- First signature: **~50-100 ms**
- Subsequent signatures: **~10-15 ms**

**Verification Performance:**
- Average: **~2-3 ms** per verification

### Lifetime 2^32 (256 Active Epochs)

**Key Generation:**
- Time: **~916 seconds** (~15.3 minutes)

**Signing Performance:**
- Average: **~30-50 ms** per signature
- First signature: **~100-200 ms**
- Subsequent signatures: **~30-40 ms**

**Verification Performance:**
- Average: **~4-5 ms** per verification

> **Note**: Key generation time scales roughly linearly with the number of active epochs. Using 1024 active epochs instead of 256 increases key generation time by approximately 4x. For lifetime 2^32 with 1024 active epochs, expect key generation to take ~60-70 minutes.

### Running Benchmarks

To run benchmarks for specific lifetimes:

```bash
# Lifetime 2^8 and 2^18 (default)
zig build test-lifetimes

# Lifetime 2^32 (requires flag)
zig build test-lifetimes -Denable-lifetime-2-32=true

# Using benchmark scripts for formatted output
bash scripts/benchmark_lifetime_2_32.sh
bash scripts/benchmark_lifetime_2_18.sh
bash scripts/benchmark_lifetime_2_8.sh
```

All benchmarks are automatically built in ReleaseFast mode for accurate performance measurements.

## Development

### Key Commands

```bash
# Build library and helper binaries
zig build
zig build install -Doptimize=ReleaseFast  # Release build

# Run tests
zig build test                    # unit + integration tests
zig build test-lifetimes          # lifetime-specific tests (2^8, 2^18)
zig build test-lifetimes -Denable-lifetime-2-32=true  # include 2^32

# Format and lint
zig build lint                    # format check

# Build Rust benchmark tools
cd benchmark/rust_benchmark
cargo build --release --bin cross_lang_rust_tool
cargo build --release --features debug-tools --bin remote_hashsig_tool  # optional
```

### Repository Layout

```
src/                    # core library
  core/                 # field arithmetic, Poseidon2, PRF
  signature/            # Generalized XMSS implementation
    native/             # core scheme logic
    serialization.zig   # key/signature serialization
examples/              # usage + compatibility demos
benchmark/             # cross-language testing tools
  benchmark.py         # main cross-language test script
  rust_benchmark/      # Rust compatibility tools
  zig_benchmark/       # Zig compatibility tools
scripts/               # benchmark scripts for specific lifetimes
docs/                  # documentation (compatibility status, etc.)
.github/               # CI workflows
```

### Running Cross-Language Tests Locally

```bash
# Quick test (2^8 and 2^18)
python3 benchmark/benchmark.py

# Full test suite (all lifetimes)
python3 benchmark/benchmark.py --lifetime "2^8,2^18,2^32"

# Single lifetime with verbose debug logs
BENCHMARK_DEBUG_LOGS=1 python3 benchmark/benchmark.py --lifetime 2^8
```

### Debugging

For debugging cross-language compatibility issues:

1. Enable debug logs in Zig: `zig build -Ddebug-logs=true`
2. Enable verbose benchmark output: `BENCHMARK_DEBUG_LOGS=1 python3 benchmark/benchmark.py`
3. Check compatibility status: See `docs/CROSS_LANGUAGE_COMPATIBILITY_STATUS.md`

## License

Licensed under the Apache License 2.0 – see [LICENSE](LICENSE).

### Acknowledgments

- [leanSig](https://github.com/leanEthereum/leanSig) — original Rust implementation and reference tests
- [zig-poseidon](https://github.com/blockblaz/zig-poseidon) — Poseidon2 over the KoalaBear field
- [Generalized XMSS (ePrint 2025/055)](https://eprint.iacr.org/2025/055.pdf) — scheme specification
- [Rust ↔ Zig compatibility investigation](analysis/rust_zig_compatibility_investigation.md)