# hash-zig

[![CI](https://github.com/ch4r10t33r/hash-zig/actions/workflows/ci.yml/badge.svg)](https://github.com/ch4r10t33r/hash-zig/actions/workflows/ci.yml)
[![Zig](https://img.shields.io/badge/zig-0.14.1-orange.svg)](https://ziglang.org/)
[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](LICENSE)

A pure Zig implementation of hash-based signatures using **Poseidon2** and **SHA3** with incomparable encodings. This library implements XMSS-like signatures based on the framework from [this paper](https://eprint.iacr.org/2025/055.pdf), with parameters matching the [hash-sig](https://github.com/b-wagn/hash-sig) Rust implementation. Poseidon2 here targets the KoalaBear 31‚Äëbit field with Montgomery arithmetic (compatible with plonky3 constants), optimized for throughput.

## üåü Features

- **Multiple Hash Functions**: Support for both Poseidon2 (ZK-optimized) and SHA3-256 (NIST standard)
- **Poseidon2 Hash Function**: Efficient arithmetic hash (KoalaBear 31‚Äëbit field, Montgomery form), compatible with plonky3 constants
- **SHA3 Hash Function**: NIST-standardized cryptographic hash (SHA3-256)
- **128-bit Security**: Focused on a single, well-tested security level
- **Flexible Key Lifetimes**: Support from 2^10 to 2^32 signatures per keypair
- **Hypercube Parameters**: 64 chains of length 8 (w=3) as specified in [hypercube-hashsig-parameters](https://github.com/b-wagn/hypercube-hashsig-parameters)
- **Rust-Compatible Poseidon2**: Width=16, external_rounds=8, internal_rounds=20, sbox_degree=3 matching [hash-sig](https://github.com/b-wagn/hash-sig) implementation
- **Binary Encoding**: Incomparable binary encoding scheme
- **Pure Zig**: Minimal dependencies, fully type-safe
- **Well-Tested**: Comprehensive unit and integration tests
- **Parallel Key Generation**: Multi-threaded implementation with atomic work queues (~3x speedup on 8-core M2)

## üìã Table of Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [Programs](#programs)
- [Usage](#usage)
- [Configuration](#configuration)
- [Architecture](#architecture)
- [Performance](#performance)
- [Security Considerations](#security-considerations)
- [API Reference](#api-reference)
- [Testing](#testing)
- [Contributing](#contributing)
- [License](#license)

## üöÄ Installation

### Using Zig Package Manager

Add to your `build.zig.zon`:

```zig
.{
    .name = .my_project,
    .version = "0.1.0",
    .dependencies = .{
        .@"hash-zig" = .{
            .url = "https://github.com/ch4r10t33r/hash-zig/archive/refs/tags/v0.1.0.tar.gz",
            .hash = "1220...", // Will be generated by zig build
        },
    },
}
```

In your `build.zig`:

```zig
const hash_zig_dep = b.dependency("hash-zig", .{
    .target = target,
    .optimize = optimize,
});

exe.root_module.addImport("hash-zig", hash_zig_dep.module("hash-zig"));
```

### Manual Installation

```bash
git clone https://github.com/ch4r10t33r/hash-zig.git
cd hash-zig
zig build test
```

## ‚ö° Quick Start

```zig
const std = @import("std");
const hash_zig = @import("hash-zig");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Initialize with medium lifetime (2^16 signatures)
    // Only 128-bit security is supported
    const params = hash_zig.Parameters.init(.lifetime_2_16);
    var sig_scheme = try hash_zig.HashSignature.init(allocator, params);
    defer sig_scheme.deinit();

    // Generate a random seed for key generation (32 bytes required)
    var seed: [32]u8 = undefined;
    std.crypto.random.bytes(&seed);

    // Generate keypair from seed
    var keypair = try sig_scheme.generateKeyPair(allocator, &seed);
    defer keypair.deinit(allocator);

// Sign a message (index must be tracked by your application!)
const message = "Hello, hash-based signatures!";
const index: u64 = 0; // YOUR APP must track this and never reuse!
var signature = try sig_scheme.sign(allocator, message, keypair.secret_key, index);
defer signature.deinit(allocator);

// Verify signature
const is_valid = try sig_scheme.verify(allocator, message, signature, keypair.public_key);
std.debug.print("Signature valid: {}\n", .{is_valid});
}
```

## üõ†Ô∏è Programs

The hash-zig library includes several built-in programs for demonstration, testing, and performance analysis:

### Basic Example (`hash-zig-example`)
**Purpose**: Demonstrates basic usage of the hash-zig library
**Command**: `zig build example` or `zig build run`
**Description**: Shows how to generate keypairs, sign messages, and verify signatures. Includes timing measurements and displays key information. Perfect for understanding the library's core functionality.

### Performance Profiler (`hash-zig-profile`)
**Purpose**: Detailed performance analysis and profiling
**Command**: `zig build profile`
**Description**: Provides in-depth timing analysis of individual operations including WOTS (Winternitz One-Time Signature) operations, hash functions, and full key generation. Useful for understanding performance bottlenecks and optimization opportunities.

### Performance Benchmark (`hash-zig-benchmark`)
**Purpose**: Comprehensive performance benchmarking
**Command**: `zig build benchmark`
**Description**: Runs standardized performance tests across different key lifetimes (2^10 and 2^16). Measures key generation, signing, and verification times with detailed metrics. Outputs results in CI-friendly format for automated testing.

### SIMD Benchmark (`hash-zig-simd-benchmark`)
**Purpose**: Tests SIMD-optimized implementations
**Command**: `zig build simd-benchmark`
**Description**: Benchmarks SIMD-optimized versions of the hash-based signature scheme. Tests both 2^10 and 2^16 lifetimes with SIMD acceleration. Useful for comparing performance improvements from vectorization.

### Implementation Comparison (`hash-zig-compare`)
**Purpose**: Direct performance comparison between Optimized V2 and SIMD implementations
**Command**: `zig build compare`
**Description**: Compares the performance of Optimized V2 vs SIMD implementations using identical hypercube parameters (64 chains of length 8) and the same seed. Both implementations use Rust-compatible Poseidon2 (width=16). Shows detailed timing analysis, key structure differences, and performance ratios. Demonstrates the performance characteristics of different implementation approaches.

### Building All Programs
```bash
# Build all executables
zig build

# Run specific programs
zig build example      # Basic usage demo
zig build profile      # Performance profiling
zig build benchmark    # Standard benchmark
zig build simd-benchmark  # SIMD benchmark
zig build compare      # Compare Optimized V2 vs SIMD
```

### Program Outputs
All programs provide detailed timing information and can be used for:
- **Development**: Understanding library behavior and performance characteristics
- **Testing**: Verifying correct implementation and performance expectations
- **Benchmarking**: Comparing different implementations and optimizations
- **CI/CD**: Automated performance regression testing

### Performance Comparison Results

The `hash-zig-compare` program demonstrates the performance characteristics of different implementations:

**Current Results (Apple M2, lifetime 2^10, hypercube parameters):**
- **Optimized V2**: Uses Rust-compatible Poseidon2 (width=16) with hypercube parameters
- **SIMD**: Uses SIMD-optimized Poseidon2 (width=16) with hypercube parameters
- **Parameters**: Both use 64 chains of length 8 (w=3) as specified in [hypercube-hashsig-parameters](https://github.com/b-wagn/hypercube-hashsig-parameters)

**Key Characteristics:**
- **Both Implementations**: Use identical hypercube parameters (64 chains of length 8)
- **Both Implementations**: Use Rust-compatible Poseidon2 (width=16, external_rounds=8, internal_rounds=20, sbox_degree=3)
- **Same Security**: Both provide 128-bit post-quantum security
- **Same Seed**: Both use the same seed for consistent comparison
- **Different Approaches**: Optimized V2 uses standard implementation, SIMD uses vectorized operations

This comparison highlights the performance characteristics of different implementation approaches while maintaining identical security properties and parameters.

## üìñ Usage

### Basic Signing and Verification

```zig
const hash_zig = @import("hash-zig");

// Configure parameters with Poseidon2 (default)
// 128-bit security with hypercube parameters: 64 chains of length 8 (w=3)
const params = hash_zig.Parameters.initHypercube(.lifetime_2_16);
var sig = try hash_zig.HashSignature.init(allocator, params);
defer sig.deinit();

// Generate a random seed (32 bytes required)
var seed: [32]u8 = undefined;
std.crypto.random.bytes(&seed);

// Generate keys from seed
var keypair = try sig.generateKeyPair(allocator, &seed);
defer keypair.deinit(allocator);

// Sign (YOU must track indices and never reuse!)
const index: u64 = 0; // Track this in your app's database!
var signature = try sig.sign(allocator, "message", keypair.secret_key, index);
defer signature.deinit(allocator);

// Verify
const valid = try sig.verify(allocator, "message", signature, keypair.public_key);
```

### Deterministic Key Generation

The `generateKeyPair` function requires a 32-byte seed. You can use this for:
- **Random key generation**: Use `std.crypto.random.bytes(&seed)`
- **Deterministic key generation**: Derive seed from a password/phrase using a KDF
- **Key recovery**: Store the seed securely to regenerate the same keypair

```zig
// Random key generation (default approach)
var random_seed: [32]u8 = undefined;
std.crypto.random.bytes(&random_seed);
var keypair = try sig.generateKeyPair(allocator, &random_seed);

// Deterministic key generation from a known seed
const deterministic_seed: [32]u8 = .{1} ** 32; // Use a proper KDF in production!
var keypair2 = try sig.generateKeyPair(allocator, &deterministic_seed);
// Same seed will always generate the same keypair
```

### Using SHA3 Hash Function

```zig
// Initialize with SHA3-256 instead of Poseidon2
const params = hash_zig.Parameters.initWithSha3(.lifetime_2_16);

// Everything else works the same way
var sig = try hash_zig.HashSignature.init(allocator, params);
defer sig.deinit();
```

### Hash Function Selection

```zig
// Poseidon2 with hypercube parameters (default) - optimized for ZK proof systems
const params_p2 = hash_zig.Parameters.initHypercube(.lifetime_2_16);

// SHA3-256 - NIST standard
const params_sha3 = hash_zig.Parameters.initWithSha3(.lifetime_2_16);

// Default parameters (Poseidon2 with lifetime_2_16)
const params_default = hash_zig.Parameters.initDefault();
```

### Different Key Lifetimes

```zig
// lifetime_2_10: 2^10 = 1,024 signatures
const params_short = hash_zig.Parameters.init(.lifetime_2_10);

// lifetime_2_16: 2^16 = 65,536 signatures (default)
const params_medium = hash_zig.Parameters.init(.lifetime_2_16);

// lifetime_2_18: 2^18 = 262,144 signatures (for benchmarking against Rust impl)
const params_benchmark = hash_zig.Parameters.init(.lifetime_2_18);

// lifetime_2_20: 2^20 = 1,048,576 signatures
const params_long = hash_zig.Parameters.init(.lifetime_2_20);

// lifetime_2_28: 2^28 = 268,435,456 signatures
const params_very_long = hash_zig.Parameters.init(.lifetime_2_28);

// lifetime_2_32: 2^32 = 4,294,967,296 signatures
const params_extreme = hash_zig.Parameters.init(.lifetime_2_32);
```

## ‚öôÔ∏è Configuration

### Security Parameters

Using hypercube parameters as specified in [hypercube-hashsig-parameters](https://github.com/b-wagn/hypercube-hashsig-parameters):

| Parameter | Value | Notes |
|-----------|-------|-------|
| Security Level | 128-bit | Post-quantum secure |
| Hash Output | 32 bytes | 256-bit hash for 128-bit security |
| Encoding | Binary | Incomparable binary encoding |
| Winternitz w | 3 | Chain length 8 (2^3 = 8) |
| Number of Chains | 64 | Hypercube parameter specification |
| Chain Length | 8 | Winternitz parameter w=3 |
| Poseidon2 Width | 16 | Rust-compatible (external_rounds=8, internal_rounds=20, sbox_degree=3) |

**Note**: These parameters use the hypercube configuration (64 chains of length 8) as specified in the [hypercube-hashsig-parameters](https://github.com/b-wagn/hypercube-hashsig-parameters) repository, with Rust-compatible Poseidon2 parameters for interoperability.

### Hash Functions

| Function | Security | Output Size | Use Case |
|----------|----------|-------------|----------|
| Poseidon2 | 128-bit | 32 bytes | ZK proofs, arithmetic circuits |
| SHA3-256 | 128-bit | 32 bytes | NIST standard, general crypto |

Both hash functions provide 128-bit post-quantum security with 32-byte (256-bit) output.

### Key Lifetimes

| Lifetime | Tree Height | Max Signatures | Memory Required* |
|----------|-------------|----------------|------------------|
| lifetime_2_10 | 10 | 1,024 | ~32 KB |
| lifetime_2_16 | 16 | 65,536 | ~2 MB |
| lifetime_2_18 | 18 | 262,144 | ~8.4 MB |
| lifetime_2_20 | 20 | 1,048,576 | ~33 MB |
| lifetime_2_28 | 28 | 268,435,456 | ~8.6 GB |
| lifetime_2_32 | 32 | 4,294,967,296 | ~137 GB |

*Memory estimates based on 32-byte hashes and cached leaves. Actual memory usage may vary.

## üèóÔ∏è Architecture

```
hash-zig/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ root.zig              # Main module entry point
‚îÇ   ‚îú‚îÄ‚îÄ params.zig            # Configuration and parameters
‚îÇ   ‚îú‚îÄ‚îÄ poseidon2/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ fields/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ generic_montgomery.zig   # Generic 31-bit Montgomery arithmetic
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ koalabear/montgomery.zig # KoalaBear field instance
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ instances/koalabear16.zig    # Width-16 Poseidon2 instance (plonky3 constants)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ poseidon2.zig                # Rust-compatible Poseidon2 implementation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ generic_poseidon2.zig        # Generic Poseidon2 constructor (Montgomery)
‚îÇ   ‚îú‚îÄ‚îÄ sha3.zig              # SHA3 hash implementation
‚îÇ   ‚îú‚îÄ‚îÄ encoding.zig          # Incomparable encodings
‚îÇ   ‚îú‚îÄ‚îÄ tweakable_hash.zig    # Domain-separated hashing
‚îÇ   ‚îú‚îÄ‚îÄ winternitz.zig        # Winternitz OTS
‚îÇ   ‚îú‚îÄ‚îÄ merkle.zig            # Merkle tree construction
‚îÇ   ‚îî‚îÄ‚îÄ signature.zig         # Main signature scheme
‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îî‚îÄ‚îÄ basic_usage.zig
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îî‚îÄ‚îÄ integration_test.zig
‚îî‚îÄ‚îÄ build.zig
```

### Key Components

- **Poseidon2**: Arithmetic hash over KoalaBear (31‚Äëbit) with Montgomery reduction; constants match plonky3
- **SHA3-256**: NIST-standardized Keccak-based hash for general-purpose cryptography
- **Winternitz OTS**: One-time signature with 64 chains of length 8 (w=3) using hypercube parameters
- **Merkle Tree**: Binary tree implementation for managing OTS public keys
- **Binary Encoding**: Incomparable binary encoding for 128-bit security
- **Parallel Key Generation**: Multi-threaded with atomic job queues
  - Work-queue model for WOTS leaf generation (no per-thread fixed partitions)
  - Per-thread scratch buffers in hot loops (zero per-node allocations)
  - Parallel Merkle construction using the same atomic index pattern
  - Adaptive job sizing and sequential fallback for small workloads
  - ~3x speedup on 8-core M2 Mac (hardware-dependent)

## üìä Performance

### Benchmarking Against Reference Implementation

This implementation is benchmarked against the reference Rust implementation using the [hash-sig-benchmarks](https://github.com/ch4r10t33r/hash-sig-benchmarks) suite.

The benchmark repository provides:
- **Automated comparison**: Side-by-side performance testing of Rust vs Zig implementations
- **Fair parameters**: Both implementations use identical parameters (w=8, 64 chains, Poseidon2)
- **Statistical analysis**: Multiple iterations with mean, median, and standard deviation
- **Reproducible results**: Standalone wrappers for each implementation ensure consistent testing

**Benchmark the implementations yourself**:
```bash
git clone https://github.com/ch4r10t33r/hash-sig-benchmarks.git
cd hash-sig-benchmarks
python3 benchmark.py 3  # Run 3 iterations
```

The benchmark suite automatically:
1. Clones both [hash-sig](https://github.com/b-wagn/hash-sig) (Rust) and [hash-zig](https://github.com/ch4r10t33r/hash-zig) (Zig)
2. Builds standalone benchmark wrappers for each
3. Runs key generation benchmarks with identical parameters
4. Compares and reports performance differences

### Actual Benchmarks

Measured on **Apple M2** with Zig 0.14.1, using **Poseidon2** hash and **level_128** security:

#### Core Operations (lifetime_2_10 baseline: 1,024 signatures)

| Operation | Time | Notes |
|-----------|------|-------|
| Key Generation | **32 seconds** | Parallel multi-threaded (w=8, optimized) |
| Sign | **191 ms** | Fast (uses cached leaves, 86 chains) |
| Verify | **99 ms** | Fast (only processes auth path) |

**Performance Notes:**
- Using **hypercube parameters** (64 chains of length 8, w=3) as specified in [hypercube-hashsig-parameters](https://github.com/b-wagn/hypercube-hashsig-parameters)
- Using **Rust-compatible Poseidon2** (width=16) for interoperability
- **Optimized with inline hints** for field arithmetic operations (~23% improvement)
- Parallel key generation uses all available CPU cores automatically
- Falls back to sequential mode for small workloads (< 64 leaves)
- Speedup scales with CPU core count (tested on M2 with ~3x improvement over sequential)
- Three levels of parallelization: leaf generation, WOTS chains, and Merkle tree construction
- Fast verification (~99ms) thanks to shorter chain length
- **Benchmark against Rust**: Use [hash-sig-benchmarks](https://github.com/ch4r10t33r/hash-sig-benchmarks) for head-to-head comparison
- **Hypercube Parameters**: Both Optimized V2 and SIMD implementations use identical hypercube parameters (64 chains of length 8)

#### Projected Key Generation Times for All Lifetimes

**All projections based on Apple M2 Mac (8 cores) with parallel implementation** - actual times will vary by hardware.

| Lifetime | Signatures | Tree Height | Estimated Time* | Memory Required |
|----------|-----------|-------------|-----------------|-----------------|
| lifetime_2_10 | 1,024 | 10 | **32 sec** (measured on M2, optimized) | ~33 KB |
| lifetime_2_16 | 65,536 | 16 | **~34 minutes** | ~2.1 MB |
| lifetime_2_18 | 262,144 | 18 | **~2.2 hours** | ~8.4 MB |
| lifetime_2_20 | 1,048,576 | 20 | **~9 hours** | ~34 MB |
| lifetime_2_28 | 268,435,456 | 28 | **~97 days** | ~8.6 GB |
| lifetime_2_32 | 4,294,967,296 | 32 | **~4.1 years** | ~137 GB |

*Projected by linear scaling from M2 parallel measurements with optimizations: (signatures / 1024) √ó 32 sec. 
Key generation scales O(n) with number of signatures. Performance will vary based on CPU core count and speed.

#### Sign/Verify Operations (All Lifetimes)

| Operation | Time | Complexity |
|-----------|------|------------|
| Sign | **~191 ms** | O(log n) - constant across lifetimes |
| Verify | **~99 ms** | O(log n) - constant across lifetimes |

**Note**: Signing and verification times remain nearly constant across all lifetimes because they only process the authentication path (length = tree height). Only key generation scales with the number of signatures.

### Performance Characteristics

- **Key Generation**: O(n) where n = 2^tree_height (generates all OTS keypairs and caches leaves)
- **Signing**: O(log n) with caching (generates OTS sig + retrieves auth path from cache)
- **Verification**: O(log n) (derives OTS public key + verifies Merkle path)
- **Memory**: O(n) for cached leaves (required for fast signing)

### Optimization Tips

1. Use appropriate lifetime for your use case
2. Choose hash function based on requirements:
   - **Poseidon2** for ZK-proof systems
   - **SHA3** for NIST compliance and interoperability
3. Batch key generation offline when possible
4. Always persist signature state to prevent index reuse
5. For maximum throughput use ReleaseFast, LTO, and run on CPUs with many cores
6. Benchmark large lifetimes (‚â• 2^16) to leverage parallel scheduling best

## üîí Security Considerations

### ‚ö†Ô∏è Critical Rules

1. **NEVER reuse a signature index** - Each index must be used only once
   - **Your application MUST track which indices have been used**
   - Store the last used index persistently before generating each signature
   - The library does not enforce this - it's your responsibility!
2. **Protect the secret key** - Use secure storage (encrypted, HSM, etc.)
3. **Verify signatures properly** - Always check return values
4. **Plan key rotation** - Generate new keypair before exhausting signatures

### Security Properties

- **Post-quantum secure**: Resistant to quantum attacks
- **Stateful**: Requires tracking used indices (application responsibility)
- **Forward secure**: Old signatures valid even if key compromised
- **One-time per index**: Each tree index used once only

### State Management (Application Responsibility)

**Important**: This library does NOT manage signature state. Your application MUST:

1. **Track the next available index** - Start at 0, increment after each signature
2. **Persist state before signing** - Save index to disk/database BEFORE calling `sign()`
3. **Never reuse an index** - Reusing an index can compromise security
4. **Handle crashes gracefully** - Use atomic writes or write-ahead logging

Example state management pattern:
```zig
// Pseudo-code for safe state management
fn signMessage(db: *Database, sig_scheme: *HashSignature, message: []const u8, secret_key: []const u8) !Signature {
    // 1. Get and increment index atomically
    const index = try db.getAndIncrementIndex();
    
    // 2. Persist the new index BEFORE signing
    try db.saveIndex(index + 1);
    try db.flush(); // Ensure it's on disk
    
    // 3. Now safe to sign
    return sig_scheme.sign(allocator, message, secret_key, index);
}
```

## üìö API Reference

### Parameters

```zig
// Poseidon2 (default)
const params = hash_zig.Parameters.init(.lifetime_2_16);

// SHA3-256
const params_sha3 = hash_zig.Parameters.initWithSha3(.lifetime_2_16);

// Default (Poseidon2, lifetime_2_16, 128-bit security)
const params_default = hash_zig.Parameters.initDefault();
```

### Enums

```zig
pub const SecurityLevel = enum { level_128 }; // Only 128-bit supported
pub const HashFunction = enum { poseidon2, sha3 };
pub const KeyLifetime = enum { 
    lifetime_2_10,   // 1,024 signatures
    lifetime_2_16,   // 65,536 signatures
    lifetime_2_18,   // 262,144 signatures
    lifetime_2_20,   // 1,048,576 signatures
    lifetime_2_28,   // 268,435,456 signatures
    lifetime_2_32    // 4,294,967,296 signatures
};
pub const EncodingType = enum { binary }; // Only binary encoding supported
```

## üß™ Testing

### Run All Tests

```bash
zig build test
```

### Run Linter

```bash
zig build lint
```

Note: The linter (zlinter) is a dev-time tool for this repository. Consumers of `hash-zig` do not need to depend on zlinter unless they want to run our lint target in their own CI.

### Build Library

```bash
zig build
```

### Run Example

```bash
zig build example
```

### Generate Documentation

```bash
zig build docs
```

This will generate HTML documentation in `zig-out/docs/`. Open `zig-out/docs/index.html` in your browser to view the API documentation.

### Test Examples

**Poseidon2:**
```zig
test "poseidon2 hashing" {
    const allocator = std.testing.allocator;
    const params = hash_zig.Parameters.init(.lifetime_2_16);
    
    var hash = try hash_zig.TweakableHash.init(allocator, params);
    defer hash.deinit();
    
    const result = try hash.hash(allocator, "test data", 0);
    defer allocator.free(result);
    
    try std.testing.expect(result.len == 32);
}
```

**SHA3:**
```zig
test "sha3 hashing" {
    const allocator = std.testing.allocator;
    const params = hash_zig.Parameters.initWithSha3(.lifetime_2_16);
    
    var hash = try hash_zig.TweakableHash.init(allocator, params);
    defer hash.deinit();
    
    const result = try hash.hash(allocator, "test data", 0);
    defer allocator.free(result);
    
    try std.testing.expect(result.len == 32); // SHA3-256
}
```

**Comparison:**
```zig
test "compare hash functions" {
    const allocator = std.testing.allocator;
    
    // Poseidon2
    const params_p2 = hash_zig.Parameters.init(.lifetime_2_16);
    var hash_p2 = try hash_zig.TweakableHash.init(allocator, params_p2);
    defer hash_p2.deinit();
    
    // SHA3-256
    const params_sha3 = hash_zig.Parameters.initWithSha3(.lifetime_2_16);
    var hash_sha3 = try hash_zig.TweakableHash.init(allocator, params_sha3);
    defer hash_sha3.deinit();
    
    const data = "test";
    const h1 = try hash_p2.hash(allocator, data, 0);
    defer allocator.free(h1);
    const h2 = try hash_sha3.hash(allocator, data, 0);
    defer allocator.free(h2);
    
    // Different hash functions produce different outputs
    try std.testing.expect(!std.mem.eql(u8, h1, h2));
}
```

## ü§ù Contributing

Contributions welcome! Please:

1. Fork the repository
2. Create a feature branch
3. Write tests for changes
4. Ensure tests pass (`zig build test`)
5. Run linter (`zig build lint`)
6. Open a Pull Request

### CI/CD

GitHub Actions automatically runs on pushes/PRs to `main`, `master`, or `develop`:
- Linting using [zlinter](https://github.com/kurtwagner/zlinter)
- Tests on Ubuntu, macOS, Windows
- Uses Zig 0.14.1 (required for zlinter compatibility)

See `.github/workflows/ci.yml` for details.

**Note:** The project currently requires Zig 0.14.1 because zlinter only supports the 0.14.x branch. Once zlinter adds support for Zig 0.15+, we'll update to the latest version.

## üêõ Known Issues

- Large tree generation (2^28+) requires significant time and memory resources
- No hypertree optimization for very large lifetimes
- Performance benchmarks are hardware-specific (tested only on M2 Mac)

## üìÑ License

Apache License 2.0 - see [LICENSE](LICENSE) file.

## üôè Acknowledgments
- Inspired by [Rust implementation](https://github.com/b-wagn/hash-sig)
- Framework from [hash-sig paper](https://eprint.iacr.org/2025/055.pdf)
- Poseidon2 spec from [Poseidon2 paper](https://eprint.iacr.org/2023/323.pdf)

## üìß Contact

- Issues: [GitHub Issues](https://github.com/ch4r10t33r/hash-zig/issues)
- Discussions: [GitHub Discussions](https://github.com/ch4r10t33r/hash-zig/discussions)

---

**‚ö†Ô∏è IMPORTANT DISCLAIMER**: This is a prototype implementation for research and experimentation. This code has NOT been audited and should NOT be used in production systems. **Applications using this library MUST implement proper state management to prevent signature index reuse** - the library does not enforce this.
