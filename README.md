# hash-zig

[![CI](https://github.com/blockblaz/hash-zig/actions/workflows/ci.yml/badge.svg)](https://github.com/blockblaz/hash-zig/actions/workflows/ci.yml)
[![Zig](https://img.shields.io/badge/zig-0.14.1-orange.svg)](https://ziglang.org/)
[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](LICENSE)

Pure Zig implementation of **Generalized XMSS** signatures with wire-compatible behavior against the Rust reference implementation ([leanSig](https://github.com/leanEthereum/leanSig)). Keys, signatures, and Merkle paths interchange freely between the two ecosystems for lifetimes `2^8`, `2^18`, and `2^32`.

**✅ Cross-Language Compatibility**: All cross-language compatibility tests pass for lifetimes `2^8` and `2^32` in both directions (Rust↔Zig). For lifetime `2^18`, all flows pass except **Zig sign → Rust verify**, which currently fails only on the Rust side; this is being tracked as a known limitation of the 2^18 instantiation.

**⚠️ Prototype Status**: This is a prototype implementation for research and development purposes. Use at your own risk.

- **Protocol fidelity** – Poseidon2 hashing, ShakePRF domain separation, target sum encoding, and Merkle construction match the Rust reference bit-for-bit.
- **Multiple lifetimes** – `2^8`, `2^18`, `2^32` signatures per key with configurable activation windows (defaults to 256 epochs).
- **Interop-first CI & tooling** – `github/workflows/ci.yml` runs `benchmark/benchmark.py`, covering same-language and cross-language checks for lifetimes `2^8` and `2^18`. Locally, test all lifetimes (`2^8`, `2^18`, `2^32`) via `--lifetime` and enable verbose logs only when needed with `BENCHMARK_DEBUG_LOGS=1`.
- **Performance optimizations** – Parallel tree generation and SIMD optimizations for improved key generation performance (46.5% faster for 2^32 with 1024 active epochs).
- **Pure Zig** – minimal dependencies, explicit memory management, ReleaseFast-ready.

## Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [Cross-Language Compatibility Tests](#cross-language-compatibility-tests)
- [Performance Benchmarks](#performance-benchmarks)
- [Optimisations Implemented](#optimisations-implemented)
- [Development](#development)
- [Debug Logging](#debug-logging)
- [License](#license)

## Installation

### Using the Zig package manager

`build.zig.zon`:

```zig
.{
    .name = "my_project",
    .version = "0.1.0",
    .dependencies = .{
        .@"hash-zig" = .{
            .url = "https://github.com/ch4r10t33r/hash-zig/archive/refs/tags/v2.0.0.tar.gz",
            .hash = "1220...", // generated by zig build
        },
        .@"zig-poseidon" = .{
            .url = "https://github.com/blockblaz/zig-poseidon/archive/refs/heads/main.tar.gz",
            .hash = "1220...", // generated by zig build
        },
    },
}
```

`build.zig`:

```zig
const hash_zig_dep = b.dependency("hash-zig", .{ .target = target, .optimize = optimize });
const zig_poseidon_dep = b.dependency("zig_poseidon", .{ .target = target, .optimize = optimize });

exe.root_module.addImport("hash-zig", hash_zig_dep.module("hash-zig"));
exe.root_module.addImport("poseidon", zig_poseidon_dep.module("poseidon"));
```

### Manual

```bash
git clone https://github.com/ch4r10t33r/hash-zig.git
cd hash-zig
zig build test
```

## Quick Start

### Basic Usage

```zig
const std = @import("std");
const hash_zig = @import("hash-zig");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Initialize scheme with desired lifetime
    var scheme = try hash_zig.GeneralizedXMSSSignatureScheme.init(allocator, .lifetime_2_8);
    defer scheme.deinit();

    // Generate keypair (start_epoch=0, num_active_epochs=256)
    const keypair = try scheme.keyGen(0, 256);
    defer keypair.secret_key.deinit();

    // Sign a message at epoch 0
    const message = [_]u8{0x42} ** 32;
    const signature = try scheme.sign(keypair.secret_key, 0, message);
    defer signature.deinit();

    // Verify the signature
    const ok = try scheme.verify(&keypair.public_key, 0, message, signature);
    std.debug.print("Signature valid: {}\n", .{ok});
}
```

### Using a Deterministic Seed

For reproducible key generation (useful for testing and cross-language compatibility):

```zig
// Generate a 32-byte seed
const seed = [_]u8{0x42} ** 32;

// Initialize scheme with seed
var scheme = try hash_zig.GeneralizedXMSSSignatureScheme.initWithSeed(
    allocator, 
    .lifetime_2_8, 
    seed
);
defer scheme.deinit();

// Generate keypair (deterministic based on seed)
const keypair = try scheme.keyGen(0, 256);
```

### Available Lifetimes

- `.lifetime_2_8` - 256 signatures (fast, suitable for testing)
- `.lifetime_2_18` - 262,144 signatures (production use)
- `.lifetime_2_32` - 4,294,967,296 signatures (experimental, very slow keygen)

> **Performance Note**: For lifetimes `2^18` and `2^32`, always compile with `zig build -Doptimize=ReleaseFast` for acceptable performance. Debug builds will be extremely slow for larger lifetimes.

## Cross-Language Compatibility Tests

**Cross-language compatibility status:**

- ✅ **Lifetime `2^8`**: All combinations pass (Rust sign → Rust/Zig verify, Zig sign → Zig/Rust verify).
- ⚠️ **Lifetime `2^18`**: Rust sign → Rust/Zig verify and Zig sign → Zig verify pass; **Zig sign → Rust verify currently fails** due to a mismatch in the 2^18 instantiation on the Rust side.
- ✅ **Lifetime `2^32`**: All combinations pass (Rust sign → Rust/Zig verify, Zig sign → Zig/Rust verify).

### Quick Start

```bash
# Run all supported lifetimes
python3 benchmark/benchmark.py --lifetime "2^8,2^18,2^32"

# Run specific lifetime
python3 benchmark/benchmark.py --lifetime 2^32

# Enable verbose debug logs
BENCHMARK_DEBUG_LOGS=1 python3 benchmark/benchmark.py --lifetime 2^8
```

The script automatically builds both implementations and runs comprehensive cross-language tests (Rust ↔ Zig signing and verification).

### Test Results

**Lifetime 2^32 (256 active epochs):**
- ✅ Rust keygen: ~2.0s, Zig keygen: ~1.3s
- ✅ All verification tests pass

**Lifetime 2^32 (1024 active epochs):**
- ✅ Zig keygen: ~51.7s (46.5% faster with parallel optimization)
- ✅ All verification tests pass

See [Performance Benchmarks](#performance-benchmarks) for detailed timing information.

## Performance Benchmarks

Performance measurements are taken using `zig build test-lifetimes` with ReleaseFast optimization. All benchmarks are run with debug logging disabled for accurate performance measurements.

### Lifetime 2^8 (256 Active Epochs)

**Key Generation:**
- Time: **~1.2 seconds**

**Signing Performance:**
- Average: **~5-10 ms** per signature
- First signature (epoch 0): **~280 ms** (includes tree building)
- Subsequent signatures: **~4-6 ms**

**Verification Performance:**
- Average: **~1-2 ms** per verification

### Lifetime 2^18 (256 Active Epochs)

**Key Generation:**
- Time: **~10-20 seconds**

**Signing Performance:**
- Average: **~10-20 ms** per signature
- First signature: **~50-100 ms**
- Subsequent signatures: **~10-15 ms**

**Verification Performance:**
- Average: **~2-3 ms** per verification

### Lifetime 2^32 (256 Active Epochs)

**Key Generation:**
- Time: **~916 seconds** (~15.3 minutes)

**Signing Performance:**
- Average: **~30-50 ms** per signature
- First signature: **~100-200 ms**
- Subsequent signatures: **~30-40 ms**

**Verification Performance:**
- Average: **~4-5 ms** per verification

### Lifetime 2^32 (1024 Active Epochs) - With Parallel Tree Generation

**Key Generation:**
- Time: **~51.7 seconds** (with parallel tree generation)
- Previous baseline: **~96.6 seconds** (sequential generation)
- **Improvement: 46.5% faster (1.87x speedup)**

**Performance Optimization:**
- Parallel bottom tree generation utilizes all available CPU cores
- Multiple trees are generated simultaneously instead of sequentially
- Maintains 100% Rust compatibility (same trees, same root hash)

> **Note**: Key generation time scales roughly linearly with the number of active epochs. The parallel tree generation optimization significantly improves performance for larger active epoch windows. For lifetime 2^32 with 1024 active epochs, parallel generation reduces key generation time from ~96.6 seconds to ~51.7 seconds.

### Running Benchmarks

```bash
# Lifetime 2^8 and 2^18 (default)
zig build test-lifetimes

# Lifetime 2^32 (requires flag)
zig build test-lifetimes -Denable-lifetime-2-32=true

# Test parallel tree generation (2^32 with 1024 active epochs)
zig build benchmark-parallel -Doptimize=ReleaseFast
```

## Optimisations Implemented

This section provides a summary of optimizations implemented in the Zig implementation compared to the Rust reference implementation.

| Optimization | Rust | Zig | Status | Impact on 2^32 | Compatibility |
|--------------|------|-----|--------|----------------|---------------|
| **1. Parallel Bottom Tree Generation** | ✅ `into_par_iter()` | ✅ `std.Thread` | **MATCHED** | High (46.5% improvement) | ✅ Safe |
| **2. SIMD Chain Computation** | ✅ `PackedF` (PR #5) | ✅ Full SIMD Poseidon2 implemented and enabled | **MATCHED** | **Very High** (69% improvement achieved) | ✅ Safe |
| **3. Parallel Top Tree Building** | ✅ `par_chunks_exact(2)` | ✅ `processPairsInParallel` | **MATCHED** | Medium | ✅ Safe |
| **4. Parallel Leaf Computation** | ✅ `par_chunks_exact(width)` | ✅ `std.Thread` | **MATCHED** | High | ✅ Safe |
| **5. Bottom Tree Caching** | ❌ No | ✅ HashMap | **AHEAD** | Medium (repeated runs) | ✅ Safe |
| **6. Batch Hash Operations** | ✅ Via SIMD | ✅ Batch of 4 | **PARTIAL** | Low-Medium | ✅ Safe |
| **7. Signing Tree Reuse** | ✅ Yes | ✅ Yes | **MATCHED** | N/A (signing) | ✅ Safe |

**Current Performance (2^32, 1024 epochs):**
- Rust: **~2.0-3.2s**
- Zig: **~17.9s** (after full SIMD implementation, down from 57.9s baseline)
- Gap: **~5.6-9x slower** (down from ~18x)
- **Note**: Full SIMD Poseidon2 is implemented and enabled, providing 69% improvement from baseline

**Current Performance (2^32, 256 epochs) - ✅ VERIFIED:**
- Rust: **2.000s**
- Zig: **1.316s** (Zig faster in this case)
- Gap: **Zig is faster** (thread-level parallelism working well)
- **Status**: All cross-language compatibility tests pass ✅

**Primary Bottleneck:** Hash function efficiency - Rust uses optimized Plonky3 SIMD, Zig uses custom SIMD implementation. Further optimizations may close the remaining gap.

For detailed analysis and recommendations, see [RUST_VS_ZIG_OPTIMIZATIONS.md](docs/RUST_VS_ZIG_OPTIMIZATIONS.md).

## Development

### Key Commands

```bash
# Build library and helper binaries
zig build
zig build install -Doptimize=ReleaseFast  # Release build

# Run tests
zig build test                    # unit + integration tests
zig build test-lifetimes          # lifetime-specific tests (2^8, 2^18)
zig build test-lifetimes -Denable-lifetime-2-32=true  # include 2^32

# Format and lint
zig build lint                    # format check

# Build Rust benchmark tools
cd benchmark/rust_benchmark
cargo build --release --bin cross_lang_rust_tool
cargo build --release --features debug-tools --bin remote_hashsig_tool  # optional
```

### Repository Layout

```
src/                    # core library
  core/                 # field arithmetic, Poseidon2, PRF
  signature/            # Generalized XMSS implementation
    native/             # core scheme logic
    serialization.zig   # key/signature serialization
examples/              # usage + compatibility demos
benchmark/             # cross-language testing tools
  benchmark.py         # main cross-language test script
  rust_benchmark/      # Rust compatibility tools
  zig_benchmark/       # Zig compatibility tools
scripts/               # benchmark scripts for specific lifetimes
docs/                  # documentation (compatibility status, etc.)
.github/               # CI workflows
```

### Running Cross-Language Tests

```bash
# Quick test (2^8 and 2^18)
python3 benchmark/benchmark.py

# Full test suite (all lifetimes)
python3 benchmark/benchmark.py --lifetime "2^8,2^18,2^32"
```

## Debug Logging

Debug logging is controlled by a build-time flag `-Ddebug-logs` (defaults to `false`). When disabled, there is zero performance overhead.

### Usage

```bash
# Default: debug logs disabled (optimal performance)
zig build test-lifetimes -OReleaseFast

# Enable debug logs for debugging
zig build test-lifetimes -OReleaseFast -Ddebug-logs=true
```

### Debug Log Categories

- `ZIG_SIGN_DEBUG`: Signing operation logs
- `ZIG_VERIFY_DEBUG`: Verification operation logs
- `ZIG_HASH_CALL`: Hash function call logs
- `ZIG_BUILDTREE`: Tree building logs
- `DEBUG:`: General debug messages

### Performance Impact

- **Disabled (default)**: Zero overhead, compiler optimizes away logging code
- **Enabled**: Full logging with performance impact from I/O operations

**Best Practice**: Always use default (disabled) for benchmarking. Enable only when debugging.

## License

Licensed under the Apache License 2.0 – see [LICENSE](LICENSE).

### Acknowledgments

- [leanSig](https://github.com/leanEthereum/leanSig) — original Rust implementation and reference tests
- [zig-poseidon](https://github.com/blockblaz/zig-poseidon) — Poseidon2 over the KoalaBear field
- [Generalized XMSS (ePrint 2025/055)](https://eprint.iacr.org/2025/055.pdf) — scheme specification
- [Rust ↔ Zig compatibility investigation](analysis/rust_zig_compatibility_investigation.md)