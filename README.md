# hash-zig

[![CI](https://github.com/ch4r10t33r/hash-zig/actions/workflows/ci.yml/badge.svg)](https://github.com/ch4r10t33r/hash-zig/actions/workflows/ci.yml)
[![Zig](https://img.shields.io/badge/zig-0.14.1-orange.svg)](https://ziglang.org/)
[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](LICENSE)

A pure Zig implementation of hash-based signatures using **Poseidon2** and **SHA3** hash functions with incomparable encodings. This library implements XMSS-like signatures based on the framework from [this paper](https://eprint.iacr.org/2025/055.pdf).

## üåü Features

- **Multiple Hash Functions**: Support for both Poseidon2 (ZK-optimized) and SHA3 (NIST standard)
- **Poseidon2 Hash Function**: Efficient arithmetic hash optimized for zero-knowledge proof systems
- **SHA3 Hash Function**: NIST-standardized cryptographic hash (SHA3-256, SHA3-384, SHA3-512)
- **Multiple Security Levels**: 128-bit, 192-bit, and 256-bit security
- **Flexible Key Lifetimes**: Support from 2^10 to 2^32 signatures per keypair
- **Incomparable Encodings**: Binary, ternary, and quaternary encoding schemes
- **Hypertree Optimization**: Efficient handling of large signature trees
- **Pure Zig**: Minimal dependencies, fully type-safe
- **Well-Tested**: Comprehensive unit and integration tests

## üìã Table of Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [Usage](#usage)
- [Configuration](#configuration)
- [Architecture](#architecture)
- [Performance](#performance)
- [Security Considerations](#security-considerations)
- [API Reference](#api-reference)
- [Testing](#testing)
- [Contributing](#contributing)
- [License](#license)

## üöÄ Installation

### Using Zig Package Manager

Add to your `build.zig.zon`:

```zig
.{
    .name = .my_project,
    .version = "0.1.0",
    .dependencies = .{
        .@"hash-zig" = .{
            .url = "https://github.com/ch4r10t33r/hash-zig/archive/refs/tags/v0.1.0.tar.gz",
            .hash = "1220...", // Will be generated by zig build
        },
    },
}
```

In your `build.zig`:

```zig
const hash_zig_dep = b.dependency("hash-zig", .{
    .target = target,
    .optimize = optimize,
});

exe.root_module.addImport("hash-zig", hash_zig_dep.module("hash-zig"));
```

### Manual Installation

```bash
git clone https://github.com/ch4r10t33r/hash-zig.git
cd hash-zig
zig build test
```

## ‚ö° Quick Start

```zig
const std = @import("std");
const hash_zig = @import("hash-zig");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Initialize with 128-bit security and medium lifetime (2^16 signatures)
    const params = hash_zig.Parameters.init(.level_128, .lifetime_2_16);
    var sig_scheme = try hash_zig.HashSignature.init(allocator, params);
    defer sig_scheme.deinit();

    // Generate keypair
    var keypair = try sig_scheme.generateKeyPair(allocator);
    defer keypair.deinit(allocator);

    // Sign a message
    const message = "Hello, hash-based signatures!";
    var signature = try sig_scheme.sign(allocator, message, keypair.secret_key, 0);
    defer signature.deinit(allocator);

    // Verify signature
    const is_valid = try sig_scheme.verify(allocator, message, signature, keypair.public_key);
    std.debug.print("Signature valid: {}\n", .{is_valid});
}
```

## üìñ Usage

### Basic Signing and Verification

```zig
const hash_zig = @import("hash-zig");

// Configure parameters with Poseidon2 (default)
const params = hash_zig.Parameters.init(.level_128, .lifetime_2_16);
var sig = try hash_zig.HashSignature.init(allocator, params);
defer sig.deinit();

// Generate keys
var keypair = try sig.generateKeyPair(allocator);
defer keypair.deinit(allocator);

// Sign
var signature = try sig.sign(allocator, "message", keypair.secret_key, 0);
defer signature.deinit(allocator);

// Verify
const valid = try sig.verify(allocator, "message", signature, keypair.public_key);
```

### Using SHA3 Hash Function

```zig
// Initialize with SHA3-256 instead of Poseidon2
const params = hash_zig.Parameters.initWithSha3(.level_128, .lifetime_2_16);

// Everything else works the same way
var sig = try hash_zig.HashSignature.init(allocator, params);
defer sig.deinit();
```

### Different Security Levels

```zig
// 128-bit security with Poseidon2
const params_128 = hash_zig.Parameters.init(.level_128, .lifetime_2_16);

// 192-bit security with Poseidon2
const params_192 = hash_zig.Parameters.init(.level_192, .lifetime_2_16);

// 256-bit security with Poseidon2
const params_256 = hash_zig.Parameters.init(.level_256, .lifetime_2_16);

// Or use SHA3
const params_sha3 = hash_zig.Parameters.initWithSha3(.level_128, .lifetime_2_16);
```

### Different Key Lifetimes

```zig
// lifetime_2_10: 2^10 = 1,024 signatures
const params_short = hash_zig.Parameters.init(.level_128, .lifetime_2_10);

// lifetime_2_16: 2^16 = 65,536 signatures (default)
const params_medium = hash_zig.Parameters.init(.level_128, .lifetime_2_16);

// lifetime_2_20: 2^20 = 1,048,576 signatures
const params_long = hash_zig.Parameters.init(.level_128, .lifetime_2_20);

// lifetime_2_28: 2^28 = 268,435,456 signatures
const params_very_long = hash_zig.Parameters.init(.level_128, .lifetime_2_28);

// lifetime_2_32: 2^32 = 4,294,967,296 signatures
const params_extreme = hash_zig.Parameters.init(.level_128, .lifetime_2_32);
```

## ‚öôÔ∏è Configuration

### Security Levels

| Level | Hash Output | Encoding | Security Bits |
|-------|-------------|----------|---------------|
| level_128 | 32 bytes | binary | 128-bit |
| level_192 | 48 bytes | ternary | 192-bit |
| level_256 | 64 bytes | quaternary | 256-bit |

### Hash Functions

| Function | Security | Output Size | Use Case |
|----------|----------|-------------|----------|
| poseidon2_128 | 128-bit | 32 bytes | ZK proofs, arithmetic circuits |
| poseidon2_192 | 192-bit | 48 bytes | ZK proofs, arithmetic circuits |
| poseidon2_256 | 256-bit | 64 bytes | ZK proofs, arithmetic circuits |
| sha3_256 | 128-bit | 32 bytes | NIST standard, general crypto |
| sha3_384 | 192-bit | 48 bytes | NIST standard, general crypto |
| sha3_512 | 256-bit | 64 bytes | NIST standard, general crypto |

### Key Lifetimes

| Lifetime | Tree Height | Max Signatures | Memory Required* |
|----------|-------------|----------------|------------------|
| lifetime_2_10 | 10 | 1,024 | ~32 KB |
| lifetime_2_16 | 16 | 65,536 | ~2 MB |
| lifetime_2_20 | 20 | 1,048,576 | ~33 MB |
| lifetime_2_28 | 28 | 268,435,456 | ~8.6 GB |
| lifetime_2_32 | 32 | 4,294,967,296 | ~137 GB |

*Memory estimates based on 32-byte hashes. For large lifetimes, hypertree optimization is automatically used.

## üèóÔ∏è Architecture

```
hash-zig/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ root.zig              # Main module entry point
‚îÇ   ‚îú‚îÄ‚îÄ params.zig            # Configuration and parameters
‚îÇ   ‚îú‚îÄ‚îÄ poseidon2/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ field.zig         # BN254 field arithmetic
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ hash.zig          # Poseidon2 implementation
‚îÇ   ‚îú‚îÄ‚îÄ sha3.zig              # SHA3 hash implementation
‚îÇ   ‚îú‚îÄ‚îÄ encoding.zig          # Incomparable encodings
‚îÇ   ‚îú‚îÄ‚îÄ tweakable_hash.zig    # Domain-separated hashing
‚îÇ   ‚îú‚îÄ‚îÄ winternitz.zig        # Winternitz OTS
‚îÇ   ‚îú‚îÄ‚îÄ merkle.zig            # Merkle tree construction
‚îÇ   ‚îî‚îÄ‚îÄ signature.zig         # Main signature scheme
‚îú‚îÄ‚îÄ examples/
‚îÇ   ‚îî‚îÄ‚îÄ basic_usage.zig
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îî‚îÄ‚îÄ integration_test.zig
‚îî‚îÄ‚îÄ build.zig
```

### Key Components

- **Poseidon2**: Arithmetic hash over BN254 scalar field, optimized for ZK proofs
- **SHA3**: NIST-standardized Keccak-based hash for general-purpose cryptography
- **Winternitz OTS**: Efficient one-time signature scheme with configurable chain length
- **Merkle Tree**: Single tree for small lifetimes, automatic hypertree for large ones
- **Incomparable Encodings**: Binary, ternary, and quaternary encoding schemes

## üìä Performance

### Actual Benchmarks

Measured on **Apple M2** with Zig 0.14.1, using **Poseidon2** hash and **level_128** security:

#### Core Operations (lifetime_2_10 baseline: 1,024 signatures)

| Operation | Time | Notes |
|-----------|------|-------|
| Key Generation | **2.74 minutes** (164 sec) | One-time cost, builds entire tree |
| Sign | **240 ms** | Fast (uses cached leaves) |
| Verify | **198 ms** | Fast (only processes auth path) |

#### Projected Key Generation Times for All Lifetimes

| Lifetime | Signatures | Tree Height | Estimated Key Gen Time* | Memory Required |
|----------|-----------|-------------|------------------------|-----------------|
| lifetime_2_10 | 1,024 | 10 | **2.74 min** (measured) | ~33 KB |
| lifetime_2_16 | 65,536 | 16 | **~2.9 hours** | ~2.1 MB |
| lifetime_2_20 | 1,048,576 | 20 | **~47 hours** (~2 days) | ~34 MB |
| lifetime_2_28 | 268,435,456 | 28 | **~499 days** (~1.4 years) | ~8.6 GB |
| lifetime_2_32 | 4,294,967,296 | 32 | **~21 years** | ~137 GB |

*Projected by linear scaling: (signatures / 1024) √ó 2.74 min. Key generation scales O(n) with number of signatures.

#### Sign/Verify Operations (All Lifetimes)

| Operation | Time | Complexity |
|-----------|------|------------|
| Sign | **~240 ms** | O(log n) - constant across lifetimes |
| Verify | **~198 ms** | O(log n) - constant across lifetimes |

**Note**: Signing and verification times remain nearly constant across all lifetimes because they only process the authentication path (length = tree height). Only key generation scales with the number of signatures.

### Performance Characteristics

- **Key Generation**: O(n) where n = 2^tree_height (generates all OTS keypairs and caches leaves)
- **Signing**: O(log n) with caching (generates OTS sig + retrieves auth path from cache)
- **Verification**: O(log n) (derives OTS public key + verifies Merkle path)
- **Memory**: O(n) for cached leaves (required for fast signing)

### Optimization Tips

1. Use appropriate lifetime for your use case
2. Choose hash function based on requirements:
   - **Poseidon2** for ZK-proof systems
   - **SHA3** for NIST compliance and interoperability
3. Batch key generation offline when possible
4. Always persist signature state
5. Use hypertree for lifetimes > 2^20

## üîí Security Considerations

### ‚ö†Ô∏è Critical Rules

1. **NEVER reuse a signature index** - Each index must be used only once
2. **Protect the secret key** - Use secure storage (encrypted, HSM, etc.)
3. **Verify signatures properly** - Always check return values
4. **Plan key rotation** - Generate new keypair before exhausting signatures

### Security Properties

- **Post-quantum secure**: Resistant to quantum attacks
- **Stateful**: Requires tracking used indices
- **Forward secure**: Old signatures valid even if key compromised
- **One-time per index**: Each tree index used once only

## üìö API Reference

### Parameters

```zig
// Poseidon2 (default)
const params = hash_zig.Parameters.init(.level_128, .lifetime_2_16);

// SHA3
const params_sha3 = hash_zig.Parameters.initWithSha3(.level_128, .lifetime_2_16);

// Default (Poseidon2, lifetime_2_16)
const params_default = hash_zig.Parameters.initDefault(.level_128);
```

### Enums

```zig
pub const SecurityLevel = enum { level_128, level_192, level_256 };
pub const HashFunction = enum { 
    poseidon2_128, poseidon2_192, poseidon2_256,
    sha3_256, sha3_384, sha3_512
};
pub const KeyLifetime = enum { 
    lifetime_2_10,   // 1,024 signatures
    lifetime_2_16,   // 65,536 signatures
    lifetime_2_20,   // 1,048,576 signatures
    lifetime_2_28,   // 268,435,456 signatures
    lifetime_2_32    // 4,294,967,296 signatures
};
pub const EncodingType = enum { binary, ternary, quaternary };
```

## üß™ Testing

### Run All Tests

```bash
zig build test
```

### Run Linter

```bash
zig build lint
```

### Build Library

```bash
zig build
```

### Run Example

```bash
zig build example
```

### Generate Documentation

```bash
zig build docs
```

This will generate HTML documentation in `zig-out/docs/`. Open `zig-out/docs/index.html` in your browser to view the API documentation.

### Test Examples

**Poseidon2:**
```zig
test "poseidon2 hashing" {
    const allocator = std.testing.allocator;
    const params = hash_zig.Parameters.init(.level_128, .lifetime_2_16);
    
    var hash = try hash_zig.TweakableHash.init(allocator, params);
    defer hash.deinit();
    
    const result = try hash.hash(allocator, "test data", 0);
    defer allocator.free(result);
    
    try std.testing.expect(result.len == 32);
}
```

**SHA3:**
```zig
test "sha3 hashing" {
    const allocator = std.testing.allocator;
    const params = hash_zig.Parameters.initWithSha3(.level_128, .lifetime_2_16);
    
    var hash = try hash_zig.TweakableHash.init(allocator, params);
    defer hash.deinit();
    
    const result = try hash.hash(allocator, "test data", 0);
    defer allocator.free(result);
    
    try std.testing.expect(result.len == 32); // SHA3-256
}
```

**Comparison:**
```zig
test "compare hash functions" {
    const allocator = std.testing.allocator;
    
    // Poseidon2
    const params_p2 = hash_zig.Parameters.init(.level_128, .lifetime_2_16);
    var hash_p2 = try hash_zig.TweakableHash.init(allocator, params_p2);
    defer hash_p2.deinit();
    
    // SHA3
    const params_sha3 = hash_zig.Parameters.initWithSha3(.level_128, .lifetime_2_16);
    var hash_sha3 = try hash_zig.TweakableHash.init(allocator, params_sha3);
    defer hash_sha3.deinit();
    
    const data = "test";
    const h1 = try hash_p2.hash(allocator, data, 0);
    defer allocator.free(h1);
    const h2 = try hash_sha3.hash(allocator, data, 0);
    defer allocator.free(h2);
    
    // Different hash functions produce different outputs
    try std.testing.expect(!std.mem.eql(u8, h1, h2));
}
```

## ü§ù Contributing

Contributions welcome! Please:

1. Fork the repository
2. Create a feature branch
3. Write tests for changes
4. Ensure tests pass (`zig build test`)
5. Run linter (`zig build lint`)
6. Open a Pull Request

### CI/CD

GitHub Actions automatically runs on pushes/PRs to `main`, `master`, or `develop`:
- Linting using [zlinter](https://github.com/kurtwagner/zlinter)
- Tests on Ubuntu, macOS, Windows
- Uses Zig 0.14.1 (required for zlinter compatibility)

See `.github/workflows/ci.yml` for details.

**Note:** The project currently requires Zig 0.14.1 because zlinter only supports the 0.14.x branch. Once zlinter adds support for Zig 0.15+, we'll update to the latest version.

## üêõ Known Issues

- **Signature verification not fully implemented**: The verify function is a placeholder. Full XMSS verification requires Merkle authentication paths which are not yet implemented
- Hypertree authentication paths not yet implemented  
- State persistence needs implementation
- Large tree generation (2^28+) requires significant resources

**‚ö†Ô∏è Important**: This is a research/prototype implementation. The signature verification currently does not perform full Merkle tree validation and should NOT be used in production.

## üìÑ License

Apache License 2.0 - see [LICENSE](LICENSE) file.

## üôè Acknowledgments
- Inspired by [Rust implementation](https://github.com/b-wagn/hash-sig)
- Framework from [hash-sig paper](https://eprint.iacr.org/2025/055.pdf)
- Poseidon2 spec from [Poseidon2 paper](https://eprint.iacr.org/2023/323.pdf)

## üìß Contact

- Issues: [GitHub Issues](https://github.com/ch4r10t33r/hash-zig/issues)
- Discussions: [GitHub Discussions](https://github.com/ch4r10t33r/hash-zig/discussions)

---

**‚ö†Ô∏è IMPORTANT DISCLAIMER**: This is a prototype implementation for research and experimentation. The signature verification is incomplete (Merkle authentication paths not implemented). This code has NOT been audited and should NOT be used in production systems.
