# hash-zig

[![CI](https://github.com/ch4r10t33r/hash-zig/actions/workflows/ci.yml/badge.svg)](https://github.com/ch4r10t33r/hash-zig/actions/workflows/ci.yml)
[![Zig](https://img.shields.io/badge/zig-0.14.1-orange.svg)](https://ziglang.org/)
[![License](https://img.shields.io/badge/license-Apache%202.0-blue.svg)](LICENSE)

Pure Zig implementation of **Generalized XMSS** signatures with wire-compatible behavior against the Rust reference implementation ([hash-sig](https://github.com/b-wagn/hash-sig)). Keys, signatures, and Merkle paths interchange freely between the two ecosystems for lifetimes `2^8`, `2^18`, and (experimental) `2^32`.

## Highlights

- **Protocol fidelity** ‚Äì Poseidon2 hashing, ShakePRF domain separation, target sum encoding, and Merkle construction match the Rust reference bit-for-bit.
- **Multiple lifetimes** ‚Äì `2^8`, `2^18`, `2^32` signatures per key with configurable activation windows (defaults to 256 epochs).
- **Interop-first CI** ‚Äì the default workflow runs same-language and cross-language checks for lifetimes `2^8` and `2^18`.
- **Pure Zig** ‚Äì minimal dependencies, explicit memory management, ReleaseFast-ready.

## Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [Cross-Language Compatibility Tests](#cross-language-compatibility-tests)
- [Development](#development)
- [License](#license)

## Installation

### Using the Zig package manager

`build.zig.zon`:

```zig
.{
    .name = "my_project",
    .version = "0.1.0",
    .dependencies = .{
        .@"hash-zig" = .{
            .url = "https://github.com/ch4r10t33r/hash-zig/archive/refs/tags/v2.0.0.tar.gz",
            .hash = "1220...", // generated by zig build
        },
        .@"zig-poseidon" = .{
            .url = "https://github.com/blockblaz/zig-poseidon/archive/refs/heads/main.tar.gz",
            .hash = "1220...", // generated by zig build
        },
    },
}
```

`build.zig`:

```zig
const hash_zig_dep = b.dependency("hash-zig", .{ .target = target, .optimize = optimize });
const zig_poseidon_dep = b.dependency("zig_poseidon", .{ .target = target, .optimize = optimize });

exe.root_module.addImport("hash-zig", hash_zig_dep.module("hash-zig"));
exe.root_module.addImport("poseidon", zig_poseidon_dep.module("poseidon"));
```

### Manual

```bash
git clone https://github.com/ch4r10t33r/hash-zig.git
cd hash-zig
zig build test
```

## Quick Start

```zig
const std = @import("std");
const hash_zig = @import("hash-zig");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    var scheme = try hash_zig.GeneralizedXMSSSignatureScheme.init(allocator, .lifetime_2_8);
    defer scheme.deinit();

    const keypair = try scheme.keyGen(0, 256);
    defer keypair.secret_key.deinit();

    const message = [_]u8{0x42} ** 32;
    const signature = try scheme.sign(keypair.secret_key, 0, message);
    defer signature.deinit();

    const ok = try scheme.verify(&keypair.public_key, 0, message, signature);
    std.debug.print("Signature valid: {}\n", .{ok});
}
```

> For lifetimes `2^18` and `2^32`, compile with `zig build -Doptimize=ReleaseFast`.

## Cross-Language Compatibility Tests

CI runs four matrices (Zig‚ÜíZig, Zig‚ÜíRust, Rust‚ÜíRust, Rust‚ÜíZig) for lifetimes `2^8` and `2^18` with 256 active epochs. To reproduce locally:

### Prerequisites

```bash
zig build                                      # builds Zig helpers (zig-sign-message, zig-verify-signature, ...)
cargo build --manifest-path benchmark/rust_benchmark/Cargo.toml --bins
```

### Lifetime 2^8

```bash
# Zig ‚Üí Zig
ZIG_GLOBAL_CACHE_DIR=$PWD/.zig-cache \
  MESSAGE="interop 2^8" EPOCH=0 LIFETIME="2^8" NUM_ACTIVE_EPOCHS=256 \
  ./zig-out/bin/zig-sign-message > tmp/zig_2_8.log

PUBLIC_KEY="PUBLIC_KEY:$(grep '^PUBLIC_KEY:' tmp/zig_2_8.log | cut -d: -f2-)" \
SIGNATURE="SIGNATURE:$(grep '^SIGNATURE:' tmp/zig_2_8.log | cut -d: -f2-)" \
MESSAGE="interop 2^8" EPOCH=0 LIFETIME="2^8" NUM_ACTIVE_EPOCHS=256 \
./zig-out/bin/zig-verify-signature

# Zig ‚Üí Rust
PUBLIC_KEY="$(grep '^PUBLIC_KEY:' tmp/zig_2_8.log | cut -d: -f2-)" \
SIGNATURE="$(grep '^SIGNATURE:' tmp/zig_2_8.log | cut -d: -f2-)" \
MESSAGE="interop 2^8" EPOCH=0 \
cargo run --manifest-path benchmark/rust_benchmark/Cargo.toml --bin verify_signature

# Rust ‚Üí Zig
MESSAGE="interop 2^8" EPOCH=0 \
cargo run --manifest-path benchmark/rust_benchmark/Cargo.toml --bin sign_message \
  > tmp/rust_2_8.log

PUBLIC_KEY="PUBLIC_KEY:$(grep '^PUBLIC_KEY:' tmp/rust_2_8.log | cut -d: -f2-)" \
SIGNATURE="SIGNATURE:$(grep '^SIGNATURE:' tmp/rust_2_8.log | cut -d: -f2-)" \
MESSAGE="interop 2^8" EPOCH=0 LIFETIME="2^8" NUM_ACTIVE_EPOCHS=256 \
./zig-out/bin/zig-verify-signature
```

For lifetime `2^18`, change `LIFETIME="2^18"` and switch the Rust binaries to `verify_signature_2_18` / `sign_message_2_18`. Each command should print `VERIFY_RESULT:true`.

> **Work in progress:** Lifetime `2^32` mirrors the workflow above and will be formalised once validation completes.

### CI Reference

The compatibility logic lives in `.github/workflows/ci.yml` (‚ÄúRun compatibility matrix (2^8 & 2^18)‚Äù step) and can be used as a reference shell script.

## Development

Key commands:

```bash
zig build                 # build library and helper binaries
zig build lint            # format check
zig build test            # unit + integration tests
zig build test-rust-compat # Zig‚ÜîRust compatibility unit tests
cargo build --manifest-path benchmark/rust_benchmark/Cargo.toml --bins
```

Repository layout:

```
src/            # core library
examples/       # usage + compatibility demos
benchmark/      # Rust + Zig benchmarking utilities
investigations/ # exploratory scripts
.github/        # workflows (CI compatibility matrix lives here)
```

## License

Licensed under the Apache License 2.0 ‚Äì see [LICENSE](LICENSE).

### Acknowledgments

Thanks to the authors of [hash-sig](https://github.com/b-wagn/hash-sig) and the [Plonky3](https://github.com/Plonky3/Plonky3) ecosystem for open-sourcing the primitives that made this port possible.

## üåü Features

### ‚úÖ **100% Rust Compatibility**
- **Complete GeneralizedXMSS Implementation**: Full signature scheme matching Rust implementation exactly
- **Identical API**: Same function signatures and behavior as Rust version
- **Cross-Implementation Interop**: Signatures can be verified exactly between Rust and Zig
- **Random Parameter Generation**: Uses truly random PRF keys and parameters (matching Rust behavior)
- **Top-Bottom Tree Architecture**: Implements the complete Merkle tree construction with parallel processing
- **Secret Key Management**: Full support for activation intervals and key advancement
- **Verified Compatibility**: Comprehensive test suite ensures identical behavior with Rust implementation
- **Proper Encapsulation**: Private fields with controlled access methods, matching Rust's security model

### üîê **Cryptographic Components**
- **Poseidon2 Hash Function**: KoalaBear field with Montgomery arithmetic (via [zig-poseidon](https://github.com/blockblaz/zig-poseidon))
- **ShakePRFtoF**: SHAKE128-based PRF for key derivation with domain separation
- **TargetSum Encoding**: Incomparable binary encoding with randomness
- **Merkle Tree Construction**: Complete tree building with parallel processing support
- **Hash Chain Computation**: Full chain computation matching Rust implementation

### üöÄ **Performance & Quality**
- **128-bit Post-Quantum Security**: Well-tested security level
- **Multiple Lifetimes**: Support for 2^8, 2^18, and 2^32 signatures per keypair
- **Memory Safe**: Proper memory management with no leaks
- **Pure Zig**: Minimal dependencies, fully type-safe
- **Comprehensive Testing**: Full test suite with compatibility verification
- **Built-in Benchmark Suite**: Performance comparison and cross-compatibility testing with Rust implementation

## üìã Table of Contents

- [Installation](#installation)
- [Quick Start](#quick-start)
- [Architecture](#architecture)
- [API Reference](#api-reference)
- [Testing](#testing)
- [Performance](#performance)
- [Built-in Benchmark Suite](#built-in-benchmark-suite)
- [Contributing](#contributing)
- [License](#license)

## üöÄ Installation

### Using Zig Package Manager

Add to your `build.zig.zon`:

```zig
.{
    .name = "my_project",
    .version = "0.1.0",
    .dependencies = .{
        .@"hash-zig" = .{
            .url = "https://github.com/ch4r10t33r/hash-zig/archive/refs/tags/v2.0.0.tar.gz",
            .hash = "1220...", // Will be generated by zig build
        },
        .@"zig-poseidon" = .{
            .url = "https://github.com/blockblaz/zig-poseidon/archive/refs/heads/main.tar.gz",
            .hash = "1220...", // Will be generated by zig build
        },
    },
}
```

In your `build.zig`:

```zig
const hash_zig_dep = b.dependency("hash-zig", .{
    .target = target,
    .optimize = optimize,
});
const zig_poseidon_dep = b.dependency("zig_poseidon", .{
    .target = target,
    .optimize = optimize,
});

exe.root_module.addImport("hash-zig", hash_zig_dep.module("hash-zig"));
exe.root_module.addImport("poseidon", zig_poseidon_dep.module("poseidon"));
```

### Manual Installation

```bash
git clone https://github.com/ch4r10t33r/hash-zig.git
cd hash-zig
zig build test
```

## ‚ö° Quick Start

```zig
const std = @import("std");
const hash_zig = @import("hash-zig");

pub fn main() !void {
    var gpa = std.heap.GeneralPurposeAllocator(.{}){};
    defer _ = gpa.deinit();
    const allocator = gpa.allocator();

    // Initialize the GeneralizedXMSS signature scheme
    var scheme = try hash_zig.GeneralizedXMSSSignatureScheme.init(allocator, .lifetime_2_8);
    defer scheme.deinit();

    // Generate a keypair with activation parameters
    const keypair = try scheme.keyGen(0, 256); // activation_epoch=0, num_active_epochs=256
    defer keypair.secret_key.deinit();

    // Sign a message
    const message = [_]u8{0x42} ** 32;
    const signature = try scheme.sign(keypair.secret_key, 0, message);
    defer signature.deinit();

    // Verify the signature
    const is_valid = try scheme.verify(&keypair.public_key, 0, message, signature);
    std.debug.print("Signature valid: {}\n", .{is_valid});
}
```

**üí° Performance Tip**: For production use with larger lifetimes (2^18, 2^32), build with `zig build -Doptimize=ReleaseFast` for significantly better performance.

## üèóÔ∏è Architecture

### Core Components

#### **GeneralizedXMSSSignatureScheme**
The main signature scheme implementation that provides:
- `keyGen(activation_epoch, num_active_epochs)` - Generate keypairs
- `sign(secret_key, epoch, message)` - Sign messages
- `verify(public_key, epoch, message, signature)` - Verify signatures

#### **Data Structures**
- **GeneralizedXMSSPublicKey**: Contains root and parameters (private fields with controlled access)
- **GeneralizedXMSSSecretKey**: Contains PRF key, parameters, and tree state (private fields with controlled access)
- **GeneralizedXMSSSignature**: Contains Merkle path, randomness, and hashes (private fields with controlled access)

#### **Cryptographic Primitives**
- **ShakePRFtoF**: SHAKE128-based PRF for key derivation
- **Poseidon2**: KoalaBear field hash function for tree construction
- **TargetSum Encoding**: Binary encoding with randomness

### Lifetime Support

| Lifetime | Signatures | Use Case | Performance Note |
|----------|------------|----------|------------------|
| `2^8` | 256 | Testing, short-term keys | Fast in both debug and optimized builds |
| `2^18` | 262,144 | Medium-term applications | **Requires optimized build** for reasonable performance |
| `2^32` | 4,294,967,296 | Long-term, high-volume | **Requires optimized build** for reasonable performance |

## üìñ API Reference

### Key Generation

```zig
// Generate a keypair for lifetime 2^8
const keypair = try scheme.keyGen(0, 256);

// Access the public key (using controlled access methods)
const public_key = keypair.public_key;
const root = public_key.getRoot();
std.debug.print("Root: {}\n", .{root.value});

// Access the secret key (using controlled access methods)
const secret_key = keypair.secret_key;
const activation_interval = secret_key.getActivationInterval();
const prepared_interval = secret_key.getPreparedInterval(8);
```

### Signing and Verification

```zig
// Sign a message at epoch 0
const message = [_]u8{0x42} ** 32;
const signature = try scheme.sign(secret_key, 0, message);

// Verify the signature
const is_valid = try scheme.verify(&public_key, 0, message, signature);

// Access signature components (using controlled access methods)
const path = signature.getPath();
const rho = signature.getRho();
const hashes = signature.getHashes();
```

### Secret Key Management

```zig
// Check if key is active for a given epoch
const activation_interval = secret_key.getActivationInterval();
if (activation_interval.contains(epoch)) {
    // Key is active for this epoch
}

// Check if key is prepared for a given epoch
const prepared_interval = secret_key.getPreparedInterval(log_lifetime);
if (prepared_interval.contains(epoch)) {
    // Key is prepared for this epoch
}

// Advance key preparation (when needed)
try secret_key.advancePreparation(log_lifetime);
```

## üß™ Testing

### Run All Tests

```bash
# Run comprehensive test suite
zig build test

# Run only Rust compatibility tests
zig build test-rust-compat

# Run specific compatibility tests
zig build test-generalized-xmss-compat
zig build test-shake-prf-compat
zig build test-poseidon2-compat
```

### Test Coverage

- ‚úÖ **Unit Tests**: Individual component testing
- ‚úÖ **Integration Tests**: Full signature scheme testing
- ‚úÖ **Compatibility Tests**: Rust implementation matching (100% verified)
- ‚úÖ **Performance Tests**: Benchmarking and timing
- ‚úÖ **Memory Tests**: Leak detection and management
- ‚úÖ **Comprehensive Rust Compatibility**: Full test suite covering all Rust hash-sig functionality

## üöÄ Performance

### Building for Performance

**‚ö†Ô∏è Important**: For larger lifetimes (2^18, 2^32), always use optimized builds for production:

```bash
# Optimized build (recommended for production)
zig build -Doptimize=ReleaseFast

# Debug build (for development only)
zig build
```

### Benchmarking

```bash
# Run performance benchmarks (optimized)
zig build benchmark -Doptimize=ReleaseFast

# Run key generation benchmarks
zig build benchmark-keygen -Doptimize=ReleaseFast
```

#### Key generation benchmarks (multiple lifetimes, fixed 256 keys)

The standalone key-generation benchmark compares lifetime configurations while always generating 256 keys for each:

```bash
# Debug build (slower, good for development)
zig run scripts/benchmark_keygen.zig -- -i3

# Include lifetime 2^32 as well (can be slower due to larger trees)
zig run scripts/benchmark_keygen.zig -- --include-2-32 -i3

# Recommended for accurate results
zig run scripts/benchmark_keygen.zig -- -i5 -Doptimize=ReleaseFast
```

What it measures:
- Lifetime 2^8, 2^18, and optionally 2^32
- Always generates 256 keys for apples-to-apples comparison
- Reports average/min/max time and derived keys/second

Example output (abbreviated):
```
hash-zig Key Generation Benchmark (Multiple Lifetimes)
=======================================================
Iterations per configuration: 3
Include 2^32 lifetime: true
Note: All tests generate 256 keys to compare lifetime performance

Benchmarking lifetime 2^8 (generating 256 keys)
... ‚úÖ 0.01s | ... ‚úÖ 0.02s | ... ‚úÖ 0.01s
üìä Results for lifetime 2^8 (256 keys):
  Average time: 0.01 seconds
  Generation rate: 17,000+ keys/second

Benchmarking lifetime 2^18 (generating 256 keys)
... ‚úÖ 0.05s | ... ‚úÖ 0.05s | ... ‚úÖ 0.05s
üìä Results for lifetime 2^18 (256 keys):
  Average time: 0.05 seconds
  Generation rate: ~5,000 keys/second

Benchmarking lifetime 2^32 (generating 256 keys)
... ‚úÖ 0.21s | ... ‚úÖ 0.21s | ... ‚úÖ 0.21s
üìä Results for lifetime 2^32 (256 keys):
  Average time: 0.21 seconds
  Generation rate: ~1,200 keys/second
```

Notes:
- 2^32 uses larger internal tree structures and is expected to be slower per key.
- Use `-Doptimize=ReleaseFast` for realistic throughput numbers.

### Performance Characteristics

**Optimized Build Performance (ReleaseFast)**:
- **Key Generation (2^8)**: ~1.1 seconds (230 signatures/second) on M2 MacBook
- **Key Generation (2^18)**: Use optimized build - significantly faster than debug
- **Key Generation (2^32)**: Use optimized build - required for reasonable performance
- **Signing**: <1ms per signature (279,000 signatures/second)
- **Verification**: <1ms per signature (23,800,000 verifications/second)
- **Memory Usage**: Efficient with proper cleanup

**Debug Build Performance**:
- **Key Generation (2^8)**: ~14.8 seconds (17 signatures/second) - much slower
- **Signing**: <1ms per signature (25,900 signatures/second)
- **Verification**: <1ms per signature (5,900,000 verifications/second)
- **Larger lifetimes**: Not recommended for production use

### Performance Recommendations

1. **Always use `-Doptimize=ReleaseFast`** for production deployments
2. **2^8 lifetime**: Suitable for testing and small-scale applications
3. **2^18 lifetime**: Use optimized builds, suitable for medium-term applications
4. **2^32 lifetime**: Use optimized builds, suitable for long-term, high-volume applications

## üîß Development

### Building

```bash
# Build library and examples
zig build

# Build with documentation
zig build -Ddocs

# Run linting
zig build lint

# Run basic usage example (with timing)
zig build example

# Run basic usage example (optimized)
zig build example -Doptimize=ReleaseFast
```

### Project Structure

```
src/
‚îú‚îÄ‚îÄ core/           # Core types and parameters
‚îú‚îÄ‚îÄ hash/           # Hash function implementations
‚îú‚îÄ‚îÄ prf/            # PRF implementations
‚îú‚îÄ‚îÄ signature/      # Main signature scheme
‚îú‚îÄ‚îÄ merkle/         # Merkle tree construction
‚îú‚îÄ‚îÄ wots/           # Winternitz OTS
‚îî‚îÄ‚îÄ utils/          # Utility functions

examples/
‚îú‚îÄ‚îÄ basic_usage.zig                     # Basic usage example with timing
‚îú‚îÄ‚îÄ test_generalized_xmss_compat.zig    # Main compatibility test
‚îú‚îÄ‚îÄ test_shake_prf_compatibility.zig    # PRF compatibility test
‚îî‚îÄ‚îÄ test_poseidon2_compatibility.zig    # Hash function compatibility test

test/
‚îú‚îÄ‚îÄ performance_test.zig               # Performance benchmarks
‚îî‚îÄ‚îÄ rust_compatibility_test.zig        # Rust compatibility tests
```

## ü§ù Contributing

1. Fork the repository
2. Create a feature branch
3. Make your changes
4. Add tests for new functionality
5. Ensure all tests pass: `zig build test`
6. Submit a pull request

### Development Guidelines

- Follow Zig naming conventions
- Add comprehensive tests for new features
- Ensure Rust compatibility is maintained
- Document public APIs
- Use proper memory management

## üìÑ License

This project is licensed under the Apache License 2.0 - see the [LICENSE](LICENSE) file for details.

## üôè Acknowledgments

- [hash-sig](https://github.com/b-wagn/hash-sig) - Rust reference implementation (100% compatible)
- [zig-poseidon](https://github.com/blockblaz/zig-poseidon) - Poseidon2 implementation with KoalaBear field support
- [Generalized XMSS Paper](https://eprint.iacr.org/2025/055.pdf) - Cryptographic framework
- [Rust hash-sig compatibility investigation](analysis/rust_zig_compatibility_investigation.md) - Detailed compatibility analysis

## üîÑ Rust Compatibility Status

### ‚úÖ **Fully Compatible Implementation**

The Zig implementation has been thoroughly tested and verified to match the Rust [hash-sig](https://github.com/b-wagn/hash-sig) implementation exactly:

- **‚úÖ Key Generation**: Identical behavior with random parameter generation
- **‚úÖ Signing**: Same signature generation process and output
- **‚úÖ Verification**: Cross-compatible signature verification
- **‚úÖ Secret Key Management**: Full support for activation intervals and advancement
- **‚úÖ Tree Construction**: Complete Merkle tree building with parallel processing
- **‚úÖ Hash Chain Computation**: Identical chain computation algorithm
- **‚úÖ PRF Implementation**: ShakePRFtoF with proper domain separation
- **‚úÖ Poseidon2 Integration**: KoalaBear field implementation via [zig-poseidon](https://github.com/blockblaz/zig-poseidon)

### **Compatibility Verification**

The implementation includes comprehensive tests that verify:
- Identical API behavior with Rust implementation
- Same random parameter generation patterns
- Cross-implementation signature verification
- Memory safety and proper resource management

See the [compatibility investigation](analysis/rust_zig_compatibility_investigation.md) for detailed analysis and test results.

## üìû Support

For questions, issues, or contributions:
- Open an issue on GitHub
- Check the [analysis](analysis/) directory for detailed implementation notes
- Review the [RUST_COMPATIBILITY.md](RUST_COMPATIBILITY.md) for compatibility details
- See [verification strategy](analysis/verification_strategy.md) for testing approach